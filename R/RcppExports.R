# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Time-of-flight calculation.
#'
#' \code{tof} calculates the time-of-flight of ions in an ideal two-stage
#' extraction/two-stage reflection TOFMS (with second-order space focusing).
#'
#' \code{"HTOF-W"} is the W-mode and assumes hard mirror voltage = 1.5*pulse voltage.
#' \code{x} and \code{v} can be vectors, but must be the same length.
#'
#' Note: this function is not part of the TofDaq API, but is included in the
#' package for convenience.
#'
#' @param toftype TOF type (\code{"CTOF"}, \code{"HTOF"}, \code{"HTOF-W"} or \code{"LTOF"})
#' @param drift Drift tube voltage (V).
#' @param pulse Extraction pulse voltage (V).
#' @param massToCharge Mass-to-charge ratio (Th).
#' @param x Initial position deviation of the ion(s) from the extraction plane (m).
#' @param v Initial velocity of the ion(s) in extraction direction (m/s).
#'
#' @references Laiko, V.V. and A.F. Dodonov (1994), Resolution and Spectral-line
#' Shapes in the Reflecting Time-of-flight Mass Spectrometer with Orthogonally
#' Injected Ions, \emph{Rapid Communications in Mass Spectrometry}, \strong{8},
#' 720-726.
#'
#' @return Time-of-flight (s)
#'
#' @keywords internal
#' @export
tof <- function(toftype = "LTOF", drift = 6000, pulse = 1000, massToCharge = 100, x = as.numeric( c(0)), v = as.numeric( c(0))) {
    .Call(`_TofDaqR_tof`, toftype, drift, pulse, massToCharge, x, v)
}

#' Converts events of an event list into a spectrum.
#'
#' \code{EventList2TofSpec} converts events of an event list (read with
#' \code{GetEventList...FromH5} functions) into a spectrum.
#'
#' Note: this function is not part of the TofDaq API, but is included in the
#' package for convenience.
#'
#' @param events Event data, e.g. from \code{GetEventList...FromH5}.
#' @param clockPeriod Clock period (in s or ns), e.g. from
#' \code{GetFloatAttributeFromH5(filename, "FullSpectra", "ClockPeriod")}.
#' @param sampleInterval Sampling interval (in same units as \code{clockPeriod}),
#'  e.g. from \code{\link{GetH5Descriptor}}.
#' @param nbrSamples Number of samples, e.g. from \code{\link{GetH5Descriptor}}.
#' @return A vector containing the spectrum.
#' @export
EventList2TofSpec <- function(events, clockPeriod, sampleInterval, nbrSamples) {
    .Call(`_TofDaqR_EventList2TofSpec`, events, clockPeriod, sampleInterval, nbrSamples)
}

#' Decodes an event list.
#'
#' \code{DecodeEventList} decodes an event list read with \code{GetEventList...FromH5}
#' functions into a time stamp vector and a data vector.
#'
#' Note: this function is not part of the TofDaq API, but is included in the
#' package for convenience.
#'
#' @param events Event data, e.g. from \code{GetEventList...FromH5}.
#' @param clockPeriod Clock period (in s or ns), e.g. from
#' \code{GetFloatAttributeFromH5(filename, "FullSpectra", "ClockPeriod")}.
#' @param sampleInterval Sampling interval (in same units as \code{clockPeriod}),
#'  e.g. from \code{\link{GetH5Descriptor}}.
#' @return A list with sample indices and data values (in mV).
#' @export
DecodeEventList <- function(events, clockPeriod, sampleInterval) {
    .Call(`_TofDaqR_DecodeEventList`, events, clockPeriod, sampleInterval)
}

#' Decodes an event list using thresholding.
#'
#' \code{DecodeEventListThreshold} decodes an event list read with \code{GetEventList...FromH5}
#' functions into a time stamp vector and a data vector. Only event data which is
#' above the threshold (plus pre-trigger and post-trigger samples) are returned.
#'
#' Note: this function is not part of the TofDaq API, but is included in the
#' package for convenience.
#'
#' @param events Event data, e.g. from \code{GetEventList...FromH5}.
#' @param clockPeriod Clock period (in s or ns), e.g. from
#' \code{GetFloatAttributeFromH5(filename, "FullSpectra", "ClockPeriod")}.
#' @param sampleInterval Sampling interval (in same units as \code{clockPeriod}),
#'  e.g. from \code{\link{GetH5Descriptor}}.
#' @param threshold Threshold value (mV).
#' @param presamples Number of pre-trigger samples.
#' @param postsamples Number of post-trigger samples.
#' @return A list with sample indices and data values (in mV).
#'
#' @keywords internal
#' @export
DecodeEventListThreshold <- function(events, clockPeriod, sampleInterval, threshold, presamples, postsamples) {
    .Call(`_TofDaqR_DecodeEventListThreshold`, events, clockPeriod, sampleInterval, threshold, presamples, postsamples)
}

#' Processes a spectrum taken from shared memory.
#'
#' \code{SiProcessSpectrumFromShMem} processes a spectrum taken from shared
#' memory according to the options set for it's spectrum type.
#'
#' This function is a variant of the original TwToolDll function \code{\link{SiProcessSpectrum}}.
#'
#' @param specType Spectrum type index (non-negative integer).
#' @param BufIndex Buf index of data to fetch.
#' @return A list with the baseline and threshold value.
#'
#' @family Single ion histogramming functions
#' @export
SiProcessSpectrumFromShMem <- function(specType, BufIndex) {
    .Call(`_TofDaqR_SiProcessSpectrumFromShMem`, specType, BufIndex)
}

#' Keeps the shared memory acquisition buffers mapped.
#'
#' \code{KeepSharedMemMapped} Keeps the shared memory acquisition buffers mapped.
#'
#' The DLL periodically unmaps the shared memory to give the recorder
#' application the possibility to (re)allocate the shared buffers. Call this
#' function if you want to make sure that the shared memory pointers stay
#' valid while you work with them. In this case you must call
#' \code{\link{ReleaseSharedMemory}} explicitly when finished with your
#' processing operation.
#'
#' @export
KeepSharedMemMapped <- function() {
    invisible(.Call(`_TofDaqR_KeepSharedMemMapped`))
}

#' Initializes the TofDaqDll.dll.
#'
#' \code{InitializeDll} initializes the TofDaqDll.dll. It is usually not necessary
#' to call \code{InitializeDll} explicitely, as it is called automatically by
#' functions that need the DLL to be in an initialized state.
#' @export
InitializeDll <- function() {
    invisible(.Call(`_TofDaqR_InitializeDll`))
}

#' Deinitializes the TofDaqDll.dll.
#'
#' \code{CleanupDll} deinitializes the TofDaqDll.dll (frees allocated memory,
#' releases mapped shared memory and closes open files). This function is
#' automatically called when the TofDaqR package is unloaded.
#' @export
CleanupDll <- function() {
    invisible(.Call(`_TofDaqR_CleanupDll`))
}

#' Gets the version number of the TofDaq API.
#'
#' \code{GetDllVersion} gets the version number of the TofDaq API.
#' @export
GetDllVersion <- function() {
    .Call(`_TofDaqR_GetDllVersion`)
}

#' Checks if TofDaq recorder application is running.
#'
#' \code{TofDaqRunning} checks if TofDaq recorder application is running.
#'
#' @return \code{TRUE} or \code{FALSE}.
#' @export
TofDaqRunning <- function() {
    .Call(`_TofDaqR_TofDaqRunning`)
}

#' Checks if TofDaq recorder is currently acquiring data.
#'
#' \code{DaqActive} checks if TofDaq recorder is currently acquiring data.
#'
#' @return \code{TRUE} or \code{FALSE}.
#' @export
DaqActive <- function() {
    .Call(`_TofDaqR_DaqActive`)
}

#' Starts an acquisition.
#'
#' \code{StartAcquisition} starts an acquisition.
#' @export
StartAcquisition <- function() {
    invisible(.Call(`_TofDaqR_StartAcquisition`))
}

#' Stops the current acquisition.
#'
#' \code{StopAcquisition} stops the current acquisition.
#' @export
StopAcquisition <- function() {
    invisible(.Call(`_TofDaqR_StopAcquisition`))
}

#' Signals to the TofDaq recorder to continue an acquisition.
#'
#' \code{ContinueAcquisition} signals to the TofDaq recorder to continue an
#' acquisition.
#' @export
ContinueAcquisition <- function() {
    invisible(.Call(`_TofDaqR_ContinueAcquisition`))
}

#' Indicates if the TofDaq recorder expects a continue event.
#'
#' \code{ManualContinueNeeded} indicates if the TofDaq recorder expects a
#' continue event.
#'
#' @return \code{TRUE} or \code{FALSE}.
#' @export
ManualContinueNeeded <- function() {
    .Call(`_TofDaqR_ManualContinueNeeded`)
}

#' Closes the TofDaq recorder application.
#'
#' \code{CloseTofDaqRec} closes the TofDaq recorder application.
#' @export
CloseTofDaqRec <- function() {
    invisible(.Call(`_TofDaqR_CloseTofDaqRec`))
}

#' Issues a TTL pulse on the digital output line 4.
#'
#' \code{IssueDio4Pulse} issues a TTL pulse on the digital output line 4
#' specified by a delay and a pulse width.
#'
#' Note that in order for this command to work the Dio4Mode parameter must be
#' set to 2 (pulsed) or 3 (manual).
#'
#' @param delay Delay before issuing pulse in ms.
#' @param width Pulse width in ms.
#'
#' @export
IssueDio4Pulse <- function(delay, width) {
    invisible(.Call(`_TofDaqR_IssueDio4Pulse`, delay, width))
}

#' Switches the digital output line 4 between states.
#'
#' \code{SetDio4State} switches the digital output line 4 between states.
#'
#' Note that in order for this command to work the Dio4Mode parameter must be
#' set to 2 (pulsed) or 3 (manual).
#'
#' @param state 0: idle state, 1 (or any value other than 0) active state.
#'
#' @export
SetDio4State <- function(state) {
    invisible(.Call(`_TofDaqR_SetDio4State`, state))
}

#' Initializes the DAQ board.
#'
#' \code{InitializeDaqDevice} initializes the DAQ board (this is also done at
#' startup of TofDaqRec.exe). This can take up to 8 seconds depending on the
#' actual DAQ hardware.
#' @export
InitializeDaqDevice <- function() {
    invisible(.Call(`_TofDaqR_InitializeDaqDevice`))
}

#' Sets the timeout.
#'
#' \code{SetTimeout} sets the global timeout for all functions that can time
#' out. Default is 500 ms.
#'
#' @param timeout Timeout in ms. Default is 500 ms.
#' @export
SetTimeout <- function(timeout) {
    invisible(.Call(`_TofDaqR_SetTimeout`, timeout))
}

#' Gets the timeout.
#'
#' \code{GetTimeout} gets the current timeout value (in ms).
#' @export
GetTimeout <- function() {
    .Call(`_TofDaqR_GetTimeout`)
}

#' Auto setup routine for the DAQ device.
#'
#' Auto setup routine for the DAQ device. Currently implemented only for
#' AP240 averager and ndigo5G.
#' @export
AutoSetupDaqDevice <- function() {
    invisible(.Call(`_TofDaqR_AutoSetupDaqDevice`))
}

#' Arms/executes on demand mass calibration.
#'
#' \code{OnDemandMassCalibration} arms/executes on demand mass calibration.
#' Requires that parameter \code{ReCalibFreq} is set to 3 (on demand) in order to work.
#'
#' @param action 0: arms mass calibration, 1: updates mass calibration using
#' data acquired since previous arm.
#' @export
OnDemandMassCalibration <- function(action) {
    invisible(.Call(`_TofDaqR_OnDemandMassCalibration`, action))
}

#' Shows the TofDaq recorder configuration windows.
#'
#' \code{ShowConfigWindow} shows the different tabs of the TofDaq recorder
#' configuration window.
#'
#' @param ConfigWindowIndex Index of configuration tab to show (valid range: 0-6)
#' @export
ShowConfigWindow <- function(ConfigWindowIndex) {
    invisible(.Call(`_TofDaqR_ShowConfigWindow`, ConfigWindowIndex))
}

#' Loads a configuration file.
#'
#' \code{LoadIniFile} loads a configuration file (*.ini) from disk.
#'
#' @param IniFile Path/filename of the configuration file. If no path is
#' specified, the TofDaq recorder directory will be used. If \code{IniFile} is
#' an empty string or \code{NULL}, "TwApiTmpIni.ini" will be loaded.
#' @export
LoadIniFile <- function(IniFile = NULL) {
    invisible(.Call(`_TofDaqR_LoadIniFile`, IniFile))
}

#' Saves the current configuration (*.ini) to disk.
#'
#' \code{SaveIniFile} saves the current configuration (*.ini) to disk.
#'
#' @param IniFile Path/filename of the configuration file. If no path is
#' specified, the file will be saved in the TofDaq recorder directory.
#' If \code{IniFile} is an empty string or \code{NULL}, "TwApiTmpIni.ini"
#' will be used. If a path is specified, existing files cannot be overwritten.
#' @export
SaveIniFile <- function(IniFile = NULL) {
    invisible(.Call(`_TofDaqR_SaveIniFile`, IniFile))
}

#' Gets a single parameter as a string.
#'
#' \code{GetDaqParameter} gets a single parameter as a string.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameter <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameter`, Parameter)
}

#' Gets a single integer parameter.
#'
#' \code{GetDaqParameterInt} gets a single integer parameter.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterInt <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterInt`, Parameter)
}

#' Gets a single boolean parameter.
#'
#' \code{GetDaqParameterBool} gets a single boolean parameter.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterBool <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterBool`, Parameter)
}

#' Gets a single float parameter.
#'
#' \code{GetDaqParameterFloat} gets a single float parameter.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterFloat <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterFloat`, Parameter)
}

#' Gets a single int64 parameter as a string.
#'
#' \code{GetDaqParameterInt64} gets a single int64 parameter as a string.
#'
#' The return string can be converted to integer64 using
#' \code{\link[bit64:as.integer64.character]{bit64::as.integer64()}}.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterInt64 <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterInt64`, Parameter)
}

#' Gets a single double parameter.
#'
#' \code{GetDaqParameterDouble} gets a single double parameter.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterDouble <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterDouble`, Parameter)
}

#' Gets a single integer parameter.
#'
#' \code{GetDaqParameterIntRef} gets a single integer parameter.
#'
#' This is the same as \code{GetDaqParameterInt}, but additionally it checks
#' for success and a TwRetVal string is returned if it is not sucessful.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterIntRef <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterIntRef`, Parameter)
}

#' Gets a single boolean parameter.
#'
#' \code{GetDaqParameterBoolRef} gets a single boolean parameter.
#'
#' This is the same as \code{GetDaqParameterBool}, but additionally it checks
#' for success and a TwRetVal string is returned if it is not sucessful.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterBoolRef <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterBoolRef`, Parameter)
}

#' Gets a single float parameter.
#'
#' \code{GetDaqParameterFloatRef} gets a single float parameter.
#'
#' This is the same as \code{GetDaqParameterFloat}, but additionally it checks
#' for success and a TwRetVal string is returned if it is not sucessful.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterFloatRef <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterFloatRef`, Parameter)
}

#' Gets a single int64 parameter as a string.
#'
#' \code{GetDaqParameterInt64Ref} gets a single int64 parameter as a string.
#'
#' This is the same as \code{GetDaqParameterInt64}, but additionally it checks
#' for success and a TwRetVal string is returned if it is not sucessful.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterInt64Ref <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterInt64Ref`, Parameter)
}

#' Gets a single double parameter.
#'
#' \code{GetDaqParameterDoubleRef} gets a single double parameter.
#'
#' This is the same as \code{GetDaqParameterDouble}, but additionally it checks
#' for success and a TwRetVal string is returned if it is not sucessful.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterDoubleRef <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterDoubleRef`, Parameter)
}

#' Gets a single string parameter.
#'
#' \code{GetDaqParameterStringRef} gets a single string parameter.
#'
#' This is the same as \code{GetDaqParameter}, but returns \code{"TwInvalidValue"}
#' if the type of the parameter is not a string.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @export
GetDaqParameterStringRef <- function(Parameter) {
    .Call(`_TofDaqR_GetDaqParameterStringRef`, Parameter)
}

#' Sets a single parameter.
#'
#' \code{SetDaqParameter} sets a single parameter.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @param ValueString Value as a string.
#' @export
SetDaqParameter <- function(Parameter, ValueString) {
    invisible(.Call(`_TofDaqR_SetDaqParameter`, Parameter, ValueString))
}

#' Sets a single parameter with an integer value.
#'
#' \code{SetDaqParameterInt} sets a single parameter with an integer value.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @param Value Integer value.
#' @export
SetDaqParameterInt <- function(Parameter, Value) {
    invisible(.Call(`_TofDaqR_SetDaqParameterInt`, Parameter, Value))
}

#' Sets a single parameter with a boolean value.
#'
#' \code{SetDaqParameterBool} sets a single parameter with a boolean value.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @param Value \code{TRUE} or \code{FALSE}.
#' @export
SetDaqParameterBool <- function(Parameter, Value) {
    invisible(.Call(`_TofDaqR_SetDaqParameterBool`, Parameter, Value))
}

#' Sets a single parameter with a float value.
#'
#' \code{SetDaqParameterFloat} sets a single parameter with a float value.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @param Value Numeric value.
#' @export
SetDaqParameterFloat <- function(Parameter, Value) {
    invisible(.Call(`_TofDaqR_SetDaqParameterFloat`, Parameter, Value))
}

#' Sets a single parameter with an int64 value.
#'
#' \code{SetDaqParameterInt64} sets a single parameter with an int64 value
#' (passed as a string).
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @param Value int64 value passed as a string.
#' @export
SetDaqParameterInt64 <- function(Parameter, Value) {
    invisible(.Call(`_TofDaqR_SetDaqParameterInt64`, Parameter, Value))
}

#' Sets a single parameter with a double value.
#'
#' \code{SetDaqParameterDouble} sets a single parameter with a double value.
#'
#' @param Parameter Parameter name as a string. See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm#parameter_list}{TofDaq API documentation}
#' for a list of all available parameters.
#' @param Value Numeric value.
#' @export
SetDaqParameterDouble <- function(Parameter, Value) {
    invisible(.Call(`_TofDaqR_SetDaqParameterDouble`, Parameter, Value))
}

#' Enables and configures the "variable NbrMemories" feature.
#'
#' \code{ConfigVarNbrMemories} enables and configures the "variable NbrMemories"
#' feature.
#'
#' @param Enable \code{TRUE} to enable or \code{FALSE} to disable "variable NbrMemories"
#' feature.
#' @param StepAtBuf Buf indices for each step.
#' @param NbrMemoriesForStep NbrMemories value for each step.
#' @export
ConfigVarNbrMemories <- function(Enable, StepAtBuf, NbrMemoriesForStep) {
    invisible(.Call(`_TofDaqR_ConfigVarNbrMemories`, Enable, StepAtBuf, NbrMemoriesForStep))
}

#' Configures the mass calibration that will be used for the next acquisition.
#'
#' \code{SetMassCalib} configures the mass calibration that will be used for
#' the next acquisition(s). If \code{nbrParams} is 0, the calibration parameters are
#' determined by the TofDaq recorder based on the mass, tof and weight arrays.
#' If calibration parameters and calibration point information is supplied the
#' calibration parameters define the calibration (no "sanity" check is
#' performed whether the point information yields the same mass calibration
#' parameters).
#'
#' \tabular{cl}{
#' mode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param mode Mass calibration function to use.
#' @param nbrParams Number of mass calibration parameters.
#' @param p Vector with mass calibration parameters.
#' @param mass Vector with mass of the calibration points.
#' @param tof Vector with TOF sample index of the calibration points.
#' @param weight Vector with weight of the calibration points.
#'
#' @export
SetMassCalib <- function(mode, nbrParams, p, mass, tof, weight) {
    invisible(.Call(`_TofDaqR_SetMassCalib`, mode, nbrParams, p, mass, tof, weight))
}

#' Configures the mass calibration that will be used for the next acquisition.
#'
#' \code{SetMassCalib2} configures the mass calibration that will be used for
#' the next acquisition(s). If \code{nbrParams} is 0, the calibration parameters are
#' determined by the TofDaq recorder based on the mass, tof and weight arrays.
#' If calibration parameters and calibration point information is supplied the
#' calibration parameters define the calibration (no "sanity" check is
#' performed whether the point information yields the same mass calibration
#' parameters).
#'
#' \tabular{cl}{
#' mode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param mode Mass calibration function to use.
#' @param nbrParams Number of mass calibration parameters.
#' @param p Vector with mass calibration parameters.
#' @param mass Vector with mass of the calibration points.
#' @param tof Vector with TOF sample index of the calibration points.
#' @param weight Vector with weight of the calibration points.
#'
#' @export
SetMassCalib2 <- function(mode, nbrParams, p, mass, tof, weight) {
    invisible(.Call(`_TofDaqR_SetMassCalib2`, mode, nbrParams, p, mass, tof, weight))
}

#' Configures the mass calibration that will be used for the next acquisition.
#'
#' \code{SetMassCalibEx} configures the mass calibration that will be used for
#' the next acquisition(s). If \code{nbrParams} is 0, the calibration parameters are
#' determined by the TofDaq recorder based on the mass, tof and weight arrays.
#' If calibration parameters and calibration point information is supplied the
#' calibration parameters define the calibration (no "sanity" check is
#' performed whether the point information yields the same mass calibration
#' parameters). Labels to identify compound names/formulas used for
#' calibration have a maximum length of 255 characters.
#'
#' \tabular{cl}{
#' mode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param mode Mass calibration function to use.
#' @param nbrParams Number of mass calibration parameters.
#' @param p Vector with mass calibration parameters.
#' @param mass Vector with mass of the calibration points.
#' @param tof Vector with TOF sample index of the calibration points.
#' @param weight Vector with weight of the calibration points.
#' @param label Vector with labels of the calibration points.
#'
#' @export
SetMassCalibEx <- function(mode, nbrParams, p, mass, tof, weight, label) {
    invisible(.Call(`_TofDaqR_SetMassCalibEx`, mode, nbrParams, p, mass, tof, weight, label))
}

#' Configures the mass calibration that will be used for the next acquisition.
#'
#' \code{SetMassCalib2Ex} configures the mass calibration that will be used for
#' the next acquisition(s). If \code{nbrParams} is 0, the calibration parameters are
#' determined by the TofDaq recorder based on the mass, tof and weight arrays.
#' If calibration parameters and calibration point information is supplied the
#' calibration parameters define the calibration (no "sanity" check is
#' performed whether the point information yields the same mass calibration
#' parameters). Labels to identify compound names/formulas used for
#' calibration have a maximum length of 255 characters.
#'
#' \tabular{cl}{
#' mode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param mode Mass calibration function to use.
#' @param nbrParams Number of mass calibration parameters.
#' @param p Vector with mass calibration parameters.
#' @param mass Vector with mass of the calibration points.
#' @param tof Vector with TOF sample index of the calibration points.
#' @param weight Vector with weight of the calibration points.
#' @param label Vector with labels of the calibration points.
#'
#' @export
SetMassCalib2Ex <- function(mode, nbrParams, p, mass, tof, weight, label) {
    invisible(.Call(`_TofDaqR_SetMassCalib2Ex`, mode, nbrParams, p, mass, tof, weight, label))
}

#' Gets various information about the active acquisition.
#'
#' \code{GetDescriptor} retrieves the current TSharedMemoryDesc structure.
#' TSharedMemoryDesc contains various static information about the active
#' acquisition that can be retrieved by \code{GetDaqParameter} functions but
#' also information of DAQ progress.
#' See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TofDaqDll.htm}{TofDaq API documentation}
#' for more details.
#'
#' int64 and unsigned int64 parameters are returned as string. They can be
#' converted to integer64 using \code{\link[bit64:as.integer64.character]{bit64::as.integer64()}}.
#'
#' @return A list containing the TSharedMemoryDesc structure
#' @export
GetDescriptor <- function() {
    .Call(`_TofDaqR_GetDescriptor`)
}

#' Gets parameters for a given peak.
#'
#' \code{GetPeakParameters} gets parameters for a given peak.
#'
#' @param PeakIndex Index of peak (zero-based numbering).
#' @return A list with the peak paramters \emph{label}, \emph{mass}, \emph{loMass} and \emph{hiMass}.
#' @export
GetPeakParameters <- function(PeakIndex) {
    .Call(`_TofDaqR_GetPeakParameters`, PeakIndex)
}

#' Manually releases the shared memory acquisition buffers.
#'
#' \code{ReleaseSharedMemory} manually releases the shared memory acquisition
#' buffers. This is needed if \code{\link{KeepSharedMemMapped}} has been set to
#' \code{TRUE}.
#' @export
ReleaseSharedMemory <- function() {
    invisible(.Call(`_TofDaqR_ReleaseSharedMemory`))
}

#' Waits for new data.
#'
#' \code{WaitForNewData} waits for new data. Returns when new data is
#' available or when timed out.
#'
#' @param timeout Timeout in ms.
#' @param WaitForEventReset If \code{TRUE} (default) waits for application to
#' reset data available event before returning.
#' @export
WaitForNewData <- function(timeout, WaitForEventReset = TRUE) {
    invisible(.Call(`_TofDaqR_WaitForNewData`, timeout, WaitForEventReset))
}

#' Waits for the end of the current acquisition.
#'
#' \code{WaitForEndOfAcquisition} waits for the end of the current acquisition.
#' If \code{NbrRuns > 1} this function waits for the end of the last acquisition.
#'
#' @param timeout Timeout in ms.
#' @export
WaitForEndOfAcquisition <- function(timeout) {
    invisible(.Call(`_TofDaqR_WaitForEndOfAcquisition`, timeout))
}

#' Returns information about the current mass calibration.
#'
#' \code{GetMassCalib} returns information about the mass calibration currently
#' used in TofDaq recorder.
#'
#' @return List with calibration parameters and calibration points.
#'
#' @export
GetMassCalib <- function() {
    .Call(`_TofDaqR_GetMassCalib`)
}

#' Returns information about the current mass calibration.
#'
#' \code{GetMassCalib2} returns information about the mass calibration currently
#' used in TofDaq recorder.
#'
#' @return List with calibration parameters and calibration points.
#'
#' @export
GetMassCalib2 <- function() {
    .Call(`_TofDaqR_GetMassCalib2`)
}

#' Returns information about the current mass calibration.
#'
#' \code{GetMassCalibEx} returns information about the mass calibration currently
#' used in TofDaq recorder.
#'
#' This is the same as \code{\link{GetMassCalib}}, but additionally also returns
#' the labels of the calibration points.
#'
#' @return List with calibration parameters, calibration points and labels.
#'
#' @export
GetMassCalibEx <- function() {
    .Call(`_TofDaqR_GetMassCalibEx`)
}

#' Returns information about the current mass calibration.
#'
#' \code{GetMassCalib2Ex} returns information about the mass calibration currently
#' used in TofDaq recorder.
#'
#' This is the same as \code{\link{GetMassCalib2}}, but additionally also returns
#' the labels of the calibration points.
#'
#' @return List with calibration parameters, calibration points and labels.
#'
#' @export
GetMassCalib2Ex <- function() {
    .Call(`_TofDaqR_GetMassCalib2Ex`)
}

#' Sum spectrum from shared memory.
#'
#' \code{GetSumSpectrumFromShMem} gets the sum spectrum from shared memory.
#'
#' @param Normalize If \code{FALSE} the spectrum is reported as sum,
#' if \code{TRUE} (default) the spectrum is normalized to counts per extraction.
#' @export
GetSumSpectrumFromShMem <- function(Normalize = TRUE) {
    .Call(`_TofDaqR_GetSumSpectrumFromShMem`, Normalize)
}

#' Sum spectrum from shared memory.
#'
#' \code{GetSumSpectrumFromShMem2} gets the sum spectrum from shared memory.
#'
#' @param Normalize If \code{FALSE} the spectrum is reported as sum,
#' if \code{TRUE} (default) the spectrum is normalized to counts per extraction.
#' @export
GetSumSpectrumFromShMem2 <- function(Normalize = TRUE) {
    .Call(`_TofDaqR_GetSumSpectrumFromShMem2`, Normalize)
}

#' Single TOF spectrum from shared memory.
#'
#' \code{GetTofSpectrumFromShMem} reads a single TOF spectrum (possibly
#' averaged/summed over segment dimension) from shared memory. If
#' \code{SegmentIndex = SegmentEndIndex = -1} the complete block of data is
#' copied and the \code{Normalize} flag is ignored.
#'
#' @param SegmentIndex Segment start index of data to fetch (or -1 for complete
#' block copy).
#' @param SegmentEndIndex Segment end index of data to fetch (or -1 for complete
#' block copy).
#' @param BufIndex Buf index of data to fetch.
#' @param Normalize If \code{FALSE} the spectrum is reported as sum,
#' if \code{TRUE} (default) the spectrum is normalized to counts per extraction
#' (ignored and assumed \code{FALSE} if used with \code{SegmentIndex = SegmentEndIndex = -1}).
#' @return A vector containing the mass spectrum or an array containing the
#' block of mass spectra if \code{SegmentIndex = SegmentEndIndex = -1}.
#' @export
GetTofSpectrumFromShMem <- function(SegmentIndex, SegmentEndIndex, BufIndex, Normalize = TRUE) {
    .Call(`_TofDaqR_GetTofSpectrumFromShMem`, SegmentIndex, SegmentEndIndex, BufIndex, Normalize)
}

#' Single TOF spectrum from shared memory.
#'
#' \code{GetTofSpectrumFromShMem2} reads a single TOF spectrum (possibly
#' averaged/summed over segment dimension) from shared memory. If
#' \code{SegmentIndex = SegmentEndIndex = -1} the complete block of data is
#' copied and the \code{Normalize} flag is ignored.
#'
#' @param SegmentIndex Segment start index of data to fetch (or -1 for complete
#' block copy).
#' @param SegmentEndIndex Segment end index of data to fetch (or -1 for complete
#' block copy).
#' @param BufIndex Buf index of data to fetch.
#' @param Normalize If \code{FALSE} the spectrum is reported as sum,
#' if \code{TRUE} (default) the spectrum is normalized to counts per extraction
#' (ignored and assumed \code{FALSE} if used with \code{SegmentIndex = SegmentEndIndex = -1}).
#' @return A vector containing the mass spectrum or an array containing the
#' block of mass spectra if \code{SegmentIndex = SegmentEndIndex = -1}.
#' @export
GetTofSpectrumFromShMem2 <- function(SegmentIndex, SegmentEndIndex, BufIndex, Normalize = TRUE) {
    .Call(`_TofDaqR_GetTofSpectrumFromShMem2`, SegmentIndex, SegmentEndIndex, BufIndex, Normalize)
}

#' X-axis values of mass spectrum.
#'
#' \code{GetSpecXaxisFromShMem} returns an array of x-axis values of the mass
#' spectrum.
#'
#' @param Type x-axis type (0: sample index, 1: mass/charge [Th],
#' -1: mass/charge [Th] (2nd TOF), 2: time of flight [microsec],
#' -2: time of flight [microsec] (2nd TOF), 3: frequency [kHz]).
#' @return A vector containing the x-axis values.
#' @export
GetSpecXaxisFromShMem <- function(Type) {
    .Call(`_TofDaqR_GetSpecXaxisFromShMem`, Type)
}

#' Single stick spectrum from shared memory.
#'
#' \code{GetStickSpectrumFromShMem} reads a single stick spectrum from shared
#' memory.
#'
#' @param SegmentIndex Segment start index of data to fetch.
#' @param SegmentEndIndex Segment end index of data to fetch.
#' @param BufIndex Buf index of data to fetch.
#' @return A list containing the stick spectrum and corresponding masses.
#' @export
GetStickSpectrumFromShMem <- function(SegmentIndex, SegmentEndIndex, BufIndex) {
    .Call(`_TofDaqR_GetStickSpectrumFromShMem`, SegmentIndex, SegmentEndIndex, BufIndex)
}

#' Single stick spectrum from shared memory.
#'
#' \code{GetStickSpectrumFromShMem2} reads a single stick spectrum from shared
#' memory.
#'
#' @param SegmentIndex Segment start index of data to fetch.
#' @param SegmentEndIndex Segment end index of data to fetch.
#' @param BufIndex Buf index of data to fetch.
#' @return A list containing the stick spectrum and corresponding masses.
#' @export
GetStickSpectrumFromShMem2 <- function(SegmentIndex, SegmentEndIndex, BufIndex) {
    .Call(`_TofDaqR_GetStickSpectrumFromShMem2`, SegmentIndex, SegmentEndIndex, BufIndex)
}

#' Segment profile for a given peak and buf index from shared memory.
#'
#' \code{GetSegmentProfileFromShMem} reads the segment profile for a given
#' peak and buf index from shared memory. Use -1 for \code{PeakIndex} to get
#' segment profiles of all peaks.
#'
#' @param PeakIndex Index of peak to fetch segment profile from. All peaks are
#' read if \code{PeakIndex = -1}.
#' @param BufIndex Buf index of data to fetch.
#' @return A vector containing the segment profile(s).
#' @export
GetSegmentProfileFromShMem <- function(PeakIndex, BufIndex) {
    .Call(`_TofDaqR_GetSegmentProfileFromShMem`, PeakIndex, BufIndex)
}

#' Segment profile for a given peak and buf index from shared memory.
#'
#' \code{GetSegmentProfileFromShMem2} reads the segment profile for a given
#' peak and buf index from shared memory. Use -1 for \code{PeakIndex} to get
#' segment profiles of all peaks.
#'
#' @param PeakIndex Index of peak to fetch segment profile from. All peaks are
#' read if \code{PeakIndex = -1}.
#' @param BufIndex Buf index of data to fetch.
#' @return A vector containing the segment profile(s).
#' @export
GetSegmentProfileFromShMem2 <- function(PeakIndex, BufIndex) {
    .Call(`_TofDaqR_GetSegmentProfileFromShMem2`, PeakIndex, BufIndex)
}

#' Time stamp for a given buf and write.
#'
#' \code{GetBufTimeFromShMem} reads the time stamp for a given buf and write
#' from shared memory.
#'
#' @param BufIndex Buf index.
#' @param WriteIndex Write index.
#' @return A time stamp (in seconds relative to acquisition start).
#' @export
GetBufTimeFromShMem <- function(BufIndex, WriteIndex) {
    .Call(`_TofDaqR_GetBufTimeFromShMem`, BufIndex, WriteIndex)
}

#' Adds an entry to the acquisition log.
#'
#' \code{AddLogEntry} adds an entry to the acquisition log.
#'
#' @param LogEntryText Log text (max. 255 characters).
#' @param LogEntryTime Log entry time (number of 100-nanosecond intervals since
#' January 1, 1601 UTC, Windows FILETIME) passed as a string. Set it to "0" for
#' "now".
#'
#' @family Data storage functions
#' @export
AddLogEntry <- function(LogEntryText, LogEntryTime) {
    invisible(.Call(`_TofDaqR_AddLogEntry`, LogEntryText, LogEntryTime))
}

#' Attaches an integer attribute to the current HDF5 file.
#'
#' \code{AddAttributeInt} attaches an integer attribute to the current HDF5 file.
#'
#' @param Object HDF5 object (group or dataset) to attach attribute (max. 255
#' characters).
#' @param AttributeName Attribute name (max. 127 characters).
#' @param Value Attribute value (integer type).
#'
#' @family Data storage functions
#' @export
AddAttributeInt <- function(Object, AttributeName, Value) {
    invisible(.Call(`_TofDaqR_AddAttributeInt`, Object, AttributeName, Value))
}

#' Attaches a numeric attribute to the current HDF5 file.
#'
#' \code{AddAttributeDouble} attaches a numeric attribute to the current HDF5 file.
#'
#' @param Object HDF5 object (group or dataset) to attach attribute (max. 255
#' characters).
#' @param AttributeName Attribute name (max. 127 characters).
#' @param Value Attribute value (numeric type).
#'
#' @family Data storage functions
#' @export
AddAttributeDouble <- function(Object, AttributeName, Value) {
    invisible(.Call(`_TofDaqR_AddAttributeDouble`, Object, AttributeName, Value))
}

#' Attaches a string attribute to the current HDF5 file.
#'
#' \code{AddAttributeString} attaches a string attribute to the current HDF5 file.
#'
#' @param Object HDF5 object (group or dataset) to attach attribute (max. 255
#' characters).
#' @param AttributeName Attribute name (max. 127 characters).
#' @param Value Attribute string value (max. 255 characters).
#'
#' @family Data storage functions
#' @export
AddAttributeString <- function(Object, AttributeName, Value) {
    invisible(.Call(`_TofDaqR_AddAttributeString`, Object, AttributeName, Value))
}

#' Stores (asynchronous) user supplied data.
#'
#' \code{AddUserData} stores user supplied data asynchronously to the TOF data
#' acquistion into the current data file. Creates datasets "Data" and "Info" at
#' \code{Location}.
#'
#' @param Location Location of group in HDF5 file where the datasets are created.
#' @param NbrElements Number of elements to store (per call to this function),
#' maximum is 1048575.
#' @param Data Vector of length \code{NbrElements} containing the data to be
#' stored in dataset "Data".
#' @param ElementDescription Vector of length \code{NbrElements} containing the
#' text description of elements. If \code{ElementDescription} is \code{NULL}
#' the dataset "Info" is not created.
#' @param CompressionLevel ZLIB compression level (0-9) for dataset creation.
#' If the dataset at Location already exists this parameter has no effect.
#'
#' @family Data storage functions
#' @export
AddUserData <- function(Location, NbrElements, Data, ElementDescription = NULL, CompressionLevel = 0L) {
    invisible(.Call(`_TofDaqR_AddUserData`, Location, NbrElements, Data, ElementDescription, CompressionLevel))
}

#' Stores (asynchronous) user supplied data.
#'
#' \code{AddUserDataMultiRow} stores user supplied data asynchronously to the TOF data
#' acquistion into the current data file. Creates datasets "Data" and "Info" at
#' \code{Location}.
#'
#' Same as \code{AddUserData}, but adds argument \code{NbrRows} to add several
#' lines of user data at once.
#'
#' @param Location Location of group in HDF5 file where the datasets are created.
#' @param NbrElements Number of elements to store (per call to this function),
#' maximum is 1048575.
#' @param NbrRows Number of rows to store per call to this function (each row
#' contains \code{NbrElements} entries), maximum is 2047.
#' @param Data Vector of length \code{NbrElements*NbrRows} containing the data to be
#' stored in dataset "Data".
#' @param ElementDescription Vector of length \code{NbrElements} containing the
#' text description of elements. If \code{ElementDescription} is \code{NULL}
#' the dataset "Info" is not created.
#' @param CompressionLevel ZLIB compression level (0-9) for dataset creation.
#' If the dataset at Location already exists this parameter has no effect.
#'
#' @family Data storage functions
#' @export
AddUserDataMultiRow <- function(Location, NbrElements, NbrRows, Data, ElementDescription = NULL, CompressionLevel = 0L) {
    invisible(.Call(`_TofDaqR_AddUserDataMultiRow`, Location, NbrElements, NbrRows, Data, ElementDescription, CompressionLevel))
}

#' Registers a data source to store (synchronous) user supplied data.
#'
#' \code{RegisterUserDataBuf} registers a data source to store user supplied
#' data synchronously to the TOF data acquistion (every buf) into the data file
#' being currently recorded. Creates datasets "TwData" and "TwInfo" at \code{Location}.
#'
#' Needs to be executed before starting the acquisition.
#' Use \code{\link{UpdateUserData}} to actually store the data.
#'
#' @param Location Location of group in HDF5 file where the datasets are created.
#' @param NbrElements Number of elements to store per buf.
#' @param ElementDescription Vector of length \code{NbrElements} containing the
#' text description of elements. If \code{ElementDescription} is \code{NULL}
#' the dataset "TwInfo" is not created.
#' @param CompressionLevel Compression level used for data storage (0: no
#' compression, 1-9: increasing levels of compression (and CPU load)).
#'
#' @family Data storage functions
#' @export
RegisterUserDataBuf <- function(Location, NbrElements, ElementDescription = NULL, CompressionLevel = 0L) {
    invisible(.Call(`_TofDaqR_RegisterUserDataBuf`, Location, NbrElements, ElementDescription, CompressionLevel))
}

#' Registers a data source to store (synchronous) user supplied data.
#'
#' \code{RegisterUserDataWrite} registers a data source to store user supplied
#' data synchronously to the TOF data acquistion (every write) into the data
#' file being currently recorded. Creates datasets "TwData" and "TwInfo" at
#' \code{Location}.
#'
#' Needs to be executed before starting the acquisition.
#' Use \code{\link{UpdateUserData}} to actually store the data.
#'
#' @param Location Location of group in HDF5 file where the datasets are created.
#' @param NbrElements Number of elements to store per write.
#' @param ElementDescription Vector of length \code{NbrElements} containing the
#' text description of elements. If \code{ElementDescription} is \code{NULL}
#' the dataset "TwInfo" is not created.
#' @param CompressionLevel Compression level used for data storage (0: no
#' compression, 1-9: increasing levels of compression (and CPU load)).
#'
#' @family Data storage functions
#' @export
RegisterUserDataWrite <- function(Location, NbrElements, ElementDescription = NULL, CompressionLevel = 0L) {
    invisible(.Call(`_TofDaqR_RegisterUserDataWrite`, Location, NbrElements, ElementDescription, CompressionLevel))
}

#' Registers a data source for (synchronous) user supplied data.
#'
#' \code{RegisterUserDataNoStore} registers a data for user supplied
#' data (synchronous to the TOF data acquistion) but the data is not stored
#' in the data file.
#'
#' Needs to be executed before starting the acquisition.
#' Use \code{\link{UpdateUserData}} to update the data.
#'
#' @param Location Location of group in HDF5 file where the datasets are created.
#' @param NbrElements Number of elements to store per write.
#' @param ElementDescription Vector of length \code{NbrElements} containing the
#' text description of elements. If \code{ElementDescription} is \code{NULL}
#' the dataset "TwInfo" is not created.
#'
#' @family Data storage functions
#' @export
RegisterUserDataNoStore <- function(Location, NbrElements, ElementDescription = NULL) {
    invisible(.Call(`_TofDaqR_RegisterUserDataNoStore`, Location, NbrElements, ElementDescription))
}

#' Unregisters a data source.
#'
#' \code{UnregisterUserData} unregisters a data source previously registered
#' with \code{\link{RegisterUserDataBuf}} or \code{\link{RegisterUserDataWrite}}.
#'
#' @param Location Location of group in HDF5 file identifying the user data.
#'
#' @family Data storage functions
#' @export
UnregisterUserData <- function(Location) {
    invisible(.Call(`_TofDaqR_UnregisterUserData`, Location))
}

#' Updates the values for a registered data source.
#'
#' \code{UpdateUserData} updates the values for a registered data source.
#'
#' @param Location Location of group in HDF5 file where the datasets are created.
#' @param NbrElements Number of elements to update.
#' @param Data Vector of length \code{NbrElements} containing the new data.
#'
#' @family Data storage functions
#' @export
UpdateUserData <- function(Location, NbrElements, Data) {
    invisible(.Call(`_TofDaqR_UpdateUserData`, Location, NbrElements, Data))
}

#' Reads the current values of a registered data source.
#'
#' \code{ReadRegUserData} reads the current values of a registered data source.
#'
#' @param Location Location of group in HDF5 file where the datasets are created.
#' @param NbrElements Number of elements to read.
#' @return Vector containing the registered user data.
#'
#' @family Data storage functions
#' @export
ReadRegUserData <- function(Location, NbrElements) {
    .Call(`_TofDaqR_ReadRegUserData`, Location, NbrElements)
}

#' Queries the size of a registered data source.
#'
#' \code{QueryRegUserDataSize} queries the size (nbrElements) of a registered data source.
#'
#' @param Location Location of group in HDF5 file identifying the registered data.
#'
#' @family Data storage functions
#' @export
QueryRegUserDataSize <- function(Location) {
    .Call(`_TofDaqR_QueryRegUserDataSize`, Location)
}

#' Queries names, dimensions and types of all registered data sources.
#'
#' \code{GetRegUserDataSources} queries names, dimensions and types of all
#' data sources currently registered in TofDaq recorder.
#'
#' @return List with the location, nbrElements and type of the data sources.
#' type 1: data source values are written to disk for every write,
#' type 2: data source values are written to disk for every buf.
#'
#' @family Data storage functions
#' @export
GetRegUserDataSources <- function() {
    .Call(`_TofDaqR_GetRegUserDataSources`)
}

#' Reads the element descriptions of a registered data source.
#'
#' \code{GetRegUserDataDesc} reads the element descriptions of a registered data source.
#'
#' @param Location Location of group in HDF5 file identifying the registered data.
#'
#' @family Data storage functions
#' @export
GetRegUserDataDesc <- function(Location) {
    .Call(`_TofDaqR_GetRegUserDataDesc`, Location)
}

#' Allows to keep the data file open at the end of an acquisition.
#'
#' \code{KeepFileOpen} allows to keep the data file open at the end of an acquisition.
#'
#' @param keepOpen Issue \code{TRUE} (after DAQ start) to signal to recorder to
#' keep the data file open. When done adding data, issue \code{FALSE} to allow
#' the recorder to close the file.
#'
#' @family Data storage functions
#' @export
KeepFileOpen <- function(keepOpen) {
    invisible(.Call(`_TofDaqR_KeepFileOpen`, keepOpen))
}

#' Connects to a remote control enabled TPSController software.
#'
#' \code{TpsConnect} connects to a remote control enabled TPSController
#' software running on the same PC.
#'
#' @family TPS functions
#' @export
TpsConnect <- function() {
    invisible(.Call(`_TofDaqR_TpsConnect`))
}

#' Connects to a local or remote TPS.
#'
#' \code{TpsConnect2} connects to a local or remote TPS (TPS1: type = 0,
#' TPS2: type = 1)
#'
#' @param ip TPS2 host name or IP.
#' @param type TPS type (0: 1st generation TPS, 1: 2nd generation TPS).
#'
#' @family TPS functions
#' @export
TpsConnect2 <- function(ip, type) {
    invisible(.Call(`_TofDaqR_TpsConnect2`, ip, type))
}

#' Disconnects from a remote control enabled TPSController software.
#'
#' \code{TpsDisconnect} disconnects from a remote control enabled TPSController
#' software.
#'
#' @family TPS functions
#' @export
TpsDisconnect <- function() {
    invisible(.Call(`_TofDaqR_TpsDisconnect`))
}

#' Gets the last reported monitor value for a given module.
#'
#' \code{TpsGetMonitorValue} gets the last reported monitor value for a given
#' module.
#'
#' @param moduleCode Module code.
#'
#' @family TPS functions
#' @export
TpsGetMonitorValue <- function(moduleCode) {
    .Call(`_TofDaqR_TpsGetMonitorValue`, moduleCode)
}

#' Gets the last reported target value for a given module.
#'
#' \code{TpsGetTargetValue} gets the last reported target value for a given
#' module.
#'
#' @param moduleCode Module code.
#'
#' @family TPS functions
#' @export
TpsGetTargetValue <- function(moduleCode) {
    .Call(`_TofDaqR_TpsGetTargetValue`, moduleCode)
}

#' Gets the last reported "last set" value for a given module.
#'
#' \code{TpsGetLastSetValue} gets the last reported "last set" value for a given
#' module.
#'
#' @param moduleCode Module code.
#'
#' @family TPS functions
#' @export
TpsGetLastSetValue <- function(moduleCode) {
    .Call(`_TofDaqR_TpsGetLastSetValue`, moduleCode)
}

#' Sets the target value for a given module.
#'
#' \code{TpsSetTargetValue} sets the target value for a given module.
#'
#' @param moduleCode Module code.
#' @param value Value to set.
#'
#' @family TPS functions
#' @export
TpsSetTargetValue <- function(moduleCode, value) {
    invisible(.Call(`_TofDaqR_TpsSetTargetValue`, moduleCode, value))
}

#' Gets the number of controllable modules.
#'
#' \code{TpsGetNbrModules} gets the number of controllable modules.
#'
#' @family TPS functions
#' @export
TpsGetNbrModules <- function() {
    .Call(`_TofDaqR_TpsGetNbrModules`)
}

#' Gets the module codes of all controllable TPS modules.
#'
#' \code{TpsGetModuleCodes} gets the module codes of all controllable TPS modules.
#'
#' @family TPS functions
#' @export
TpsGetModuleCodes <- function() {
    .Call(`_TofDaqR_TpsGetModuleCodes`)
}

#' Initializes TPS.
#'
#' \code{TpsInitialize} initializes the TPS.
#'
#' @family TPS functions
#' @export
TpsInitialize <- function() {
    invisible(.Call(`_TofDaqR_TpsInitialize`))
}

#' Sets all voltages.
#'
#' \code{TpsSetAllVoltages} sets all voltages.
#'
#' @family TPS functions
#' @export
TpsSetAllVoltages <- function() {
    invisible(.Call(`_TofDaqR_TpsSetAllVoltages`))
}

#' Shuts down TPS.
#'
#' \code{TpsShutdown} shuts down the TPS.
#'
#' @family TPS functions
#' @export
TpsShutdown <- function() {
    invisible(.Call(`_TofDaqR_TpsShutdown`))
}

#' Gets the status of the TPS.
#'
#' \code{TpsGetStatus} gets the status of the TPS.
#'
#' @return List with the status information: connected?, initialized?, shutdown?,
#' ion mode changable?, ion mode supported?, current ion mode?.
#'
#' @family TPS functions
#' @export
TpsGetStatus <- function() {
    .Call(`_TofDaqR_TpsGetStatus`)
}

#' Loads a TPS set file and sets all values.
#'
#' \code{TpsLoadSetFile} loads a TPS set file and sets all values.
#'
#' @param setFile Path/filename of the set file to load.
#' @section Warning:
#' This does not just load the file (as the function name might suggest), but
#' also immediately sets all values.
#'
#' @family TPS functions
#' @export
TpsLoadSetFile <- function(setFile) {
    invisible(.Call(`_TofDaqR_TpsLoadSetFile`, setFile))
}

#' Saves the current TPS settings to a file.
#'
#' \code{TpsSaveSetFile} saves the current TPS settings to a file.
#'
#' @param setFile Path/filename of the set file to save.
#'
#' @family TPS functions
#' @export
TpsSaveSetFile <- function(setFile) {
    invisible(.Call(`_TofDaqR_TpsSaveSetFile`, setFile))
}

#' Gets the currently active filament.
#'
#' \code{TpsGetActiveFilament} gets the currently active filament.
#'
#' Note that \code{TpsGetMonitorValue} does not work to query the filament
#' number. Use this function instead.
#'
#' @return Returns 0 for Filament 1, 1 for Filament 2.
#'
#' @family TPS functions
#' @export
TpsGetActiveFilament <- function() {
    .Call(`_TofDaqR_TpsGetActiveFilament`)
}

#' Sets the active filament.
#'
#' \code{TpsSetActiveFilament} sets the active filament.
#'
#' Note that \code{TpsSetTargetValue} does not work to set the filament
#' number. Use this function instead.
#'
#' @param activeFilament 0 for Filament 1, 1 for Filament 2.
#'
#' @family TPS functions
#' @export
TpsSetActiveFilament <- function(activeFilament) {
    invisible(.Call(`_TofDaqR_TpsSetActiveFilament`, activeFilament))
}

#' Gets the limits for a given TPS module.
#'
#' \code{TpsGetModuleLimits} gets the (ion mode dependent) limits for a given TPS module. Only
#' works for TPS2.
#'
#' @param moduleCode Module code.
#'
#' @family TPS functions
#' @export
TpsGetModuleLimits <- function(moduleCode) {
    .Call(`_TofDaqR_TpsGetModuleLimits`, moduleCode)
}

#' Changes ion mode and sets target values to 0.
#'
#' \code{TpsChangeIonMode} changes ion mode (and sets target values to 0).
#'
#' Note: this is an undocumented function of TofDaqDll.dll.
#'
#' @param ionMode 0: positive ion mode, 1: negative ion mode
#'
#' @family TPS functions
#' @export
TpsChangeIonMode <- function(ionMode) {
    invisible(.Call(`_TofDaqR_TpsChangeIonMode`, ionMode))
}

#' Descriptor structure of Tofwerk HDF5 data file.
#'
#' \code{GetH5Descriptor} returns a descriptor structure for the Tofwerk HDF5 file.
#'
#' The \emph{TwH5Desc} structure contains information about data dimensions,
#' available datasets and mass calibration. Additional attributes, which are not
#' available in the structure can be read using \code{Get...AttributeFromH5}
#' functions.
#' See
#' \href{http://htmlpreview.github.io/?https://github.com/pasturm/TofDaqR/blob/master/tools/doc/TwH5Dll.htm}{TofDaq API documentation}
#' for more details.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @return A list containing the \emph{TwH5Desc} structure.
#'
#' @examples
#' \dontrun{
#' GetH5Descriptor("path/to/file.h5")
#' }
#' @export
GetH5Descriptor <- function(Filename) {
    .Call(`_TofDaqR_GetH5Descriptor`, Filename)
}

#' Closes an open HDF5 file.
#'
#' \code{CloseH5} closes an open HDF5 file.
#'
#' This function is called internally by all \code{Get..FromH5} functions, so
#' it is usually not necessary to call \code{CloseH5} explicitely.
#'
#' @param Filename Path/filename of the HDF5 file.
#'
#' @examples
#' \dontrun{
#' CloseH5("path/to/file.h5")
#' }
#' @export
CloseH5 <- function(Filename) {
    invisible(.Call(`_TofDaqR_CloseH5`, Filename))
}

#' Closes all open HDF5 files.
#'
#' \code{CloseAll} closes all open HDF5 files. It is a good idea to call this
#' function once before your program exits.
#'
#' @examples
#' \dontrun{
#' CloseAll()
#' }
#' @export
CloseAll <- function() {
    invisible(.Call(`_TofDaqR_CloseAll`))
}

#' Sum spectrum from HDF5 data file.
#'
#' \code{GetSumSpectrumFromH5} reads the sum spectrum (or average spectrum
#' depending on \code{Normalize} flag) from the HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param Normalize If \code{FALSE} (default) the spectrum is reported as sum,
#' if \code{TRUE} the spectrum is normalized to counts per extraction.
#' @return A vector containing the sum spectrum.
#'
#' @examples
#' \dontrun{
#' GetSumSpectrumFromH5("path/to/file.h5")
#' }
#' @export
GetSumSpectrumFromH5 <- function(Filename, Normalize = FALSE) {
    .Call(`_TofDaqR_GetSumSpectrumFromH5`, Filename, Normalize)
}

#' Single (averaged) TOF spectrum from HDF5 data file.
#'
#' \code{GetTofSpectrumFromH5} reads a single mass spectrum (or an
#' averaged/summed hyperslab) from the HDF5 file.
#'
#' If \code{SegmentIndex == SegmentEndIndex} and \code{BufIndex == BufEndIndex} and
#' \code{WriteIndex == WriteEndIndex} and \code{Normalize == FALSE} no
#' averaging/summing of spectra is done and the spectrum is reported as stored
#' in the dataset.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param SegmentIndex Segment start index of data to fetch.
#' @param SegmentEndIndex Segment end index of data to fetch.
#' @param BufIndex Buf start index of data to fetch.
#' @param BufEndIndex Buf end index of data to fetch.
#' @param WriteIndex Write start index of data to fetch.
#' @param WriteEndIndex Write end index of data to fetch.
#' @param BufWriteLinked Indicating whether the buf and write dimension should
#' be considered linked or treated as independent dimensions (relevant only if
#' \code{WriteIndex != WriteEndIndex}). Default is \code{FALSE}.
#' @param Normalize If \code{FALSE} the spectrum is reported as sum,
#' if \code{TRUE} (default) the spectrum is normalized to counts per extraction.
#' @return A vector containing the mass spectrum.
#'
#' @examples
#' \dontrun{
#' GetTofSpectrumFromH5("path/to/file.h5")
#' }
#' @export
GetTofSpectrumFromH5 <- function(Filename, SegmentIndex, SegmentEndIndex, BufIndex, BufEndIndex, WriteIndex, WriteEndIndex, BufWriteLinked = FALSE, Normalize = TRUE) {
    .Call(`_TofDaqR_GetTofSpectrumFromH5`, Filename, SegmentIndex, SegmentEndIndex, BufIndex, BufEndIndex, WriteIndex, WriteEndIndex, BufWriteLinked, Normalize)
}

#' Single (averaged) TOF spectrum from HDF5 data file.
#'
#' \code{GetTofSpectrum2FromH5} reads a single mass spectrum (or an
#' averaged/summed hyperslab) from the HDF5 file.
#'
#' If \code{SegmentIndex == SegmentEndIndex} and \code{BufIndex == BufEndIndex} and
#' \code{WriteIndex == WriteEndIndex} and \code{Normalize == FALSE} no
#' averaging/summing of spectra is done and the spectrum is reported as stored
#' in the dataset.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param SegmentIndex Segment start index of data to fetch.
#' @param SegmentEndIndex Segment end index of data to fetch.
#' @param BufIndex Buf start index of data to fetch.
#' @param BufEndIndex Buf end index of data to fetch.
#' @param WriteIndex Write start index of data to fetch.
#' @param WriteEndIndex Write end index of data to fetch.
#' @param BufWriteLinked Indicating whether the buf and write dimension should
#' be considered linked or treated as independent dimensions (relevant only if
#' \code{WriteIndex != WriteEndIndex}). Default is \code{FALSE}.
#' @param Normalize If \code{FALSE} the spectrum is reported as sum,
#' if \code{TRUE} (default) the spectrum is normalized to counts per extraction.
#' @return A vector containing the mass spectrum.
#'
#' @examples
#' \dontrun{
#' GetTofSpectrum2FromH5("path/to/file.h5")
#' }
#' @export
GetTofSpectrum2FromH5 <- function(Filename, SegmentIndex, SegmentEndIndex, BufIndex, BufEndIndex, WriteIndex, WriteEndIndex, BufWriteLinked = FALSE, Normalize = TRUE) {
    .Call(`_TofDaqR_GetTofSpectrum2FromH5`, Filename, SegmentIndex, SegmentEndIndex, BufIndex, BufEndIndex, WriteIndex, WriteEndIndex, BufWriteLinked, Normalize)
}

#' Single (averaged) stick spectrum from HDF5 data file.
#'
#' \code{GetStickSpectrumFromH5} reads a single stick spectrum (or an
#' averaged/summed hyperslab) from the HDF5 file.
#'
#' If \code{SegmentIndex == SegmentEndIndex} and \code{BufIndex == BufEndIndex} and
#' \code{WriteIndex == WriteEndIndex} and \code{Normalize == FALSE} no
#' averaging/summing of spectra is done and the spectrum is reported as stored
#' in the dataset.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param SegmentIndex Segment start index of data to fetch.
#' @param SegmentEndIndex Segment end index of data to fetch.
#' @param BufIndex Buf start index of data to fetch.
#' @param BufEndIndex Buf end index of data to fetch.
#' @param WriteIndex Write start index of data to fetch.
#' @param WriteEndIndex Write end index of data to fetch.
#' @param BufWriteLinked Indicating whether the buf and write dimension should
#' be considered linked or treated as independent dimensions (relevant only if
#' \code{WriteIndex != WriteEndIndex}). Default is \code{FALSE}.
#' @param Normalize If \code{FALSE} the spectrum is reported as sum,
#' if \code{TRUE} (default) the spectrum is normalized to counts per extraction.
#' @return A vector containing the stick spectrum.
#'
#' @examples
#' \dontrun{
#' GetStickSpectrumFromH5("path/to/file.h5")
#' }
#' @export
GetStickSpectrumFromH5 <- function(Filename, SegmentIndex, SegmentEndIndex, BufIndex, BufEndIndex, WriteIndex, WriteEndIndex, BufWriteLinked = FALSE, Normalize = TRUE) {
    .Call(`_TofDaqR_GetStickSpectrumFromH5`, Filename, SegmentIndex, SegmentEndIndex, BufIndex, BufEndIndex, WriteIndex, WriteEndIndex, BufWriteLinked, Normalize)
}

#' Single (averaged) stick spectrum from HDF5 data file.
#'
#' \code{GetStickSpectrum2FromH5} reads a single stick spectrum (or an
#' averaged/summed hyperslab) from the HDF5 file.
#'
#' If \code{SegmentIndex == SegmentEndIndex} and \code{BufIndex == BufEndIndex} and
#' \code{WriteIndex == WriteEndIndex} and \code{Normalize == FALSE} no
#' averaging/summing of spectra is done and the spectrum is reported as stored
#' in the dataset.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param SegmentIndex Segment start index of data to fetch.
#' @param SegmentEndIndex Segment end index of data to fetch.
#' @param BufIndex Buf start index of data to fetch.
#' @param BufEndIndex Buf end index of data to fetch.
#' @param WriteIndex Write start index of data to fetch.
#' @param WriteEndIndex Write end index of data to fetch.
#' @param BufWriteLinked Indicating whether the buf and write dimension should
#' be considered linked or treated as independent dimensions (relevant only if
#' \code{WriteIndex != WriteEndIndex}). Default is \code{FALSE}.
#' @param Normalize If \code{FALSE} the spectrum is reported as sum,
#' if \code{TRUE} (default) the spectrum is normalized to counts per extraction.
#' @return A vector containing the stick spectrum.
#'
#' @examples
#' \dontrun{
#' GetStickSpectrum2FromH5("path/to/file.h5")
#' }
#' @export
GetStickSpectrum2FromH5 <- function(Filename, SegmentIndex, SegmentEndIndex, BufIndex, BufEndIndex, WriteIndex, WriteEndIndex, BufWriteLinked = FALSE, Normalize = TRUE) {
    .Call(`_TofDaqR_GetStickSpectrum2FromH5`, Filename, SegmentIndex, SegmentEndIndex, BufIndex, BufEndIndex, WriteIndex, WriteEndIndex, BufWriteLinked, Normalize)
}

#' Peak parameters from HDF5 data file.
#'
#' \code{GetPeakParametersFromH5} reads peak parameters from the data file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param PeakIndex Index of peak (zero-based numbering). If index is -1
#' (default), peak parameters of all peaks are read.
#' @return A list with the peak paramters \emph{label}, \emph{mass}, \emph{loMass} and \emph{hiMass}.
#'
#' @examples
#' \dontrun{
#' GetPeakParametersFromH5("path/to/file.h5")
#' }
#' @export
GetPeakParametersFromH5 <- function(Filename, PeakIndex = -1L) {
    .Call(`_TofDaqR_GetPeakParametersFromH5`, Filename, PeakIndex)
}

#' Single buf timestamp from the data file.
#'
#' \code{GetBufTimeFromH5} reads a single buf time stamp from HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param BufIndex Buf index.
#' @param WriteIndex Write index.
#' @return A time stamp (in seconds relative to acquisition start).
#'
#' @examples
#' \dontrun{
#' GetBufTimeFromH5("path/to/file.h5", BufIndex = 0, WriteIndex = 0)
#' }
#' @export
GetBufTimeFromH5 <- function(Filename, BufIndex, WriteIndex) {
    .Call(`_TofDaqR_GetBufTimeFromH5`, Filename, BufIndex, WriteIndex)
}

#' x-axis values of mass spectrum.
#'
#' \code{GetSpecXaxisFromH5} returns an array of x-axis values of the mass
#' spectrum.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param Type x-axis type (0: sample index, 1: mass/charge [Th] (default),
#' -1: mass/charge [Th] (2nd TOF), 2: time of flight [microsec],
#' -2: time of flight [microsec] (2nd TOF), 3: frequency [kHz]).
#' @param writeIndex Write index to use for mass calibration (relevant only for
#' \code{abs(Type)== 1 or 2}). If the data file has no \emph{/TofData/MassCalibration}
#' dataset the standard mass calibration parameters are used (same for all
#' values of writeIndex). Default is 0.
#' @return A vector containing the x-axis values.
#'
#' @examples
#' \dontrun{
#' GetSpecXaxisFromH5("path/to/file.h5")
#' }
#' @export
GetSpecXaxisFromH5 <- function(Filename, Type = 1L, writeIndex = 0L) {
    .Call(`_TofDaqR_GetSpecXaxisFromH5`, Filename, Type, writeIndex)
}

#' Segment profile from HDF5 data file.
#'
#' \code{GetSegmentProfileFromH5} reads a segment profile for a given peak (or
#' all peaks) and buf and write slice.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param PeakIndex Index of peak to fetch segment profile from. All peaks are
#' read if \code{PeakIndex = -1}.
#' @param BufStartIndex Buf start index of data to fetch.
#' @param BufEndIndex Buf end index of data to fetch.
#' @param WriteStartIndex Write start index of data to fetch.
#' @param WriteEndIndex Write end index of data to fetch.
#' @param BufWriteLinked Indicating whether the buf and write dimension should
#' be considered linked or treated as independent dimensions (relevant only if
#' \code{WriteStartIndex != WriteEndIndex}). Default is \code{FALSE}.
#' @return A vector containing the segment profile(s).
#'
#' @examples
#' \dontrun{
#' GetSegmentProfileFromH5("path/to/file.h5", PeakIndex = -1, BufStartIndex = 0,
#' BufEndIndex = 0, WriteStartIndex = 0, WriteEndIndex = 0)
#' }
#' @export
GetSegmentProfileFromH5 <- function(Filename, PeakIndex, BufStartIndex, BufEndIndex, WriteStartIndex, WriteEndIndex, BufWriteLinked = FALSE) {
    .Call(`_TofDaqR_GetSegmentProfileFromH5`, Filename, PeakIndex, BufStartIndex, BufEndIndex, WriteStartIndex, WriteEndIndex, BufWriteLinked)
}

#' Segment profile from HDF5 data file.
#'
#' \code{GetSegmentProfile2FromH5} reads a segment profile for a given peak (or
#' all peaks) and buf and write slice.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param PeakIndex Index of peak to fetch segment profile from. All peaks are
#' read if \code{PeakIndex = -1}.
#' @param BufStartIndex Buf start index of data to fetch.
#' @param BufEndIndex Buf end index of data to fetch.
#' @param WriteStartIndex Write start index of data to fetch.
#' @param WriteEndIndex Write end index of data to fetch.
#' @param BufWriteLinked Indicating whether the buf and write dimension should
#' be considered linked or treated as independent dimensions (relevant only if
#' \code{WriteStartIndex != WriteEndIndex}). Default is \code{FALSE}.
#' @return A vector containing the segment profile(s).
#'
#' @examples
#' \dontrun{
#' GetSegmentProfile2FromH5("path/to/file.h5", PeakIndex = -1, BufStartIndex = 0,
#' BufEndIndex = 0, WriteStartIndex = 0, WriteEndIndex = 0)
#' }
#' @export
GetSegmentProfile2FromH5 <- function(Filename, PeakIndex, BufStartIndex, BufEndIndex, WriteStartIndex, WriteEndIndex, BufWriteLinked = FALSE) {
    .Call(`_TofDaqR_GetSegmentProfile2FromH5`, Filename, PeakIndex, BufStartIndex, BufEndIndex, WriteStartIndex, WriteEndIndex, BufWriteLinked)
}

#' Gets a linked buf/write profile.
#'
#' \code{GetBufWriteProfileFromH5} gets a linked buf/write profile for a given
#' peak (or all peaks) and segment slice.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param PeakIndex Index of peak to fetch buf/write profile from. All peaks are
#' read if \code{PeakIndex = -1}.
#' @param SegmentStartIndex Segment start index of data to fetch.
#' @param SegmentEndIndex Segment end index of data to fetch.
#' @return A vector containing the buf/write profile(s).
#'
#' @examples
#' \dontrun{
#' GetBufWriteProfileFromH5("path/to/file.h5", PeakIndex = -1,
#' SegmentStartIndex = 0, SegmentEndIndex = 0)
#' }
#' @export
GetBufWriteProfileFromH5 <- function(Filename, PeakIndex, SegmentStartIndex, SegmentEndIndex) {
    .Call(`_TofDaqR_GetBufWriteProfileFromH5`, Filename, PeakIndex, SegmentStartIndex, SegmentEndIndex)
}

#' Gets a linked buf/write profile.
#'
#' \code{GetBufWriteProfile2FromH5} gets a linked buf/write profile for a given
#' peak (or all peaks) and segment slice.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param PeakIndex Index of peak to fetch buf/write profile from. All peaks are
#' read if \code{PeakIndex = -1}.
#' @param SegmentStartIndex Segment start index of data to fetch.
#' @param SegmentEndIndex Segment end index of data to fetch.
#' @return A vector containing the buf/write profile(s).
#'
#' @examples
#' \dontrun{
#' GetBufWriteProfile2FromH5("path/to/file.h5", PeakIndex = -1,
#' SegmentStartIndex = 0, SegmentEndIndex = 0)
#' }
#' @export
GetBufWriteProfile2FromH5 <- function(Filename, PeakIndex, SegmentStartIndex, SegmentEndIndex) {
    .Call(`_TofDaqR_GetBufWriteProfile2FromH5`, Filename, PeakIndex, SegmentStartIndex, SegmentEndIndex)
}

#' Lists all registered user datasets available in the data file.
#'
#' \code{GetRegUserDataSourcesFromH5} lists all registered user data sets
#' available in the data file. Registered data sources can originate from data
#' source plugins, TofDaq recorder (e.g. DAQ temperatures) or data registered
#' through \code{RegisterUserData...} functions.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @return A list containing the location, the length, whether is has a description
#' and the type of the data source dataset. type 1: data source values are
#' written to disk for every write, type 2: data source values are written to
#' disk for every buf.
#'
#' @examples
#' \dontrun{
#' GetRegUserDataSourcesFromH5("path/to/file.h5")
#' }
#' @export
GetRegUserDataSourcesFromH5 <- function(Filename) {
    .Call(`_TofDaqR_GetRegUserDataSourcesFromH5`, Filename)
}

#' Reads entries from a registered data source dataset.
#'
#' \code{GetRegUserDataFromH5} reads an entry (or all entries) from a
#' registered data source dataset (created by \code{RegisterUserData...} functions).
#'
#' If \code{bufIndex = writeIndex = -1}, all data are read.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param bufIndex Buf index.
#' @param writeIndex Write index.
#' @param readDescription If \code{TRUE} (default) the data descripton is read,
#' if \code{false} the data description is not read.
#' @return A list containing the registered user data and description, or a
#' numeric vector containing the data only if \code{readDescription = FALSE}.
#'
#' @examples
#' \dontrun{
#' GetRegUserDataFromH5("path/to/file.h5", location = )
#' }
#' @export
GetRegUserDataFromH5 <- function(Filename, location, bufIndex, writeIndex, readDescription = TRUE) {
    .Call(`_TofDaqR_GetRegUserDataFromH5`, Filename, location, bufIndex, writeIndex, readDescription)
}

#' Gets data stored in /FullSpectra/TofData from HDF5 data file.
#'
#' \code{GetTofData} gets data stored in \code{/FullSpectra/TofData} from HDF5 data file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param sampleOffset Sample offset.
#' @param sampleCount Sample count.
#' @param segOffset Segment offset.
#' @param segCount Segment count.
#' @param bufOffset Buf offset.
#' @param bufCount Buf count.
#' @param writeOffset Write offset.
#' @param writeCount Write count.
#' @export
GetTofData <- function(Filename, sampleOffset, sampleCount, segOffset, segCount, bufOffset, bufCount, writeOffset, writeCount) {
    .Call(`_TofDaqR_GetTofData`, Filename, sampleOffset, sampleCount, segOffset, segCount, bufOffset, bufCount, writeOffset, writeCount)
}

#' Gets data stored in /FullSpectra2/TofData from HDF5 data file.
#'
#' \code{GetTofData2} gets data stored in \code{/FullSpectra2/TofData} from HDF5 data file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param sampleOffset Sample offset.
#' @param sampleCount Sample count.
#' @param segOffset Segment offset.
#' @param segCount Segment count.
#' @param bufOffset Buf offset.
#' @param bufCount Buf count.
#' @param writeOffset Write offset.
#' @param writeCount Write count.
#' @export
GetTofData2 <- function(Filename, sampleOffset, sampleCount, segOffset, segCount, bufOffset, bufCount, writeOffset, writeCount) {
    .Call(`_TofDaqR_GetTofData2`, Filename, sampleOffset, sampleCount, segOffset, segCount, bufOffset, bufCount, writeOffset, writeCount)
}

#' Gets data stored in /PeakData/PeakData from HDF5 data file.
#'
#' \code{GetPeakData} gets data stored in \code{/PeakData/PeakData} from HDF5 data file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param peakOffset Peak offset.
#' @param peakCount Peak count.
#' @param segOffset Segment offset.
#' @param segCount Segment count.
#' @param bufOffset Buf offset.
#' @param bufCount Buf count.
#' @param writeOffset Write offset.
#' @param writeCount Write count.
#' @export
GetPeakData <- function(Filename, peakOffset, peakCount, segOffset, segCount, bufOffset, bufCount, writeOffset, writeCount) {
    .Call(`_TofDaqR_GetPeakData`, Filename, peakOffset, peakCount, segOffset, segCount, bufOffset, bufCount, writeOffset, writeCount)
}

#' Gets data stored in /PeakData2/PeakData from HDF5 data file.
#'
#' \code{GetPeakData2} gets data stored in \code{/PeakData2/PeakData} from HDF5 data file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param peakOffset Peak offset.
#' @param peakCount Peak count.
#' @param segOffset Segment offset.
#' @param segCount Segment count.
#' @param bufOffset Buf offset.
#' @param bufCount Buf count.
#' @param writeOffset Write offset.
#' @param writeCount Write count.
#' @export
GetPeakData2 <- function(Filename, peakOffset, peakCount, segOffset, segCount, bufOffset, bufCount, writeOffset, writeCount) {
    .Call(`_TofDaqR_GetPeakData2`, Filename, peakOffset, peakCount, segOffset, segCount, bufOffset, bufCount, writeOffset, writeCount)
}

#' Gets data stored in /Timing/BufTimes from HDF5 data file.
#'
#' \code{GetTimingData} gets data stored in \code{/Timing/BufTimes} from HDF5 data file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param bufOffset Buf offset.
#' @param bufCount Buf count.
#' @param writeOffset Write offset.
#' @param writeCount Write count.
#' @export
GetTimingData <- function(Filename, bufOffset, bufCount, writeOffset, writeCount) {
    .Call(`_TofDaqR_GetTimingData`, Filename, bufOffset, bufCount, writeOffset, writeCount)
}

#' Reads an integer attribute from the HDF5 file.
#'
#' \code{GetIntAttributeFromH5} reads an integer attribute from the HDF5 file.
#'
#' Used to read attributes not available from \code{GetH5Descriptor}.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @return An integer attribute.
#'
#' @examples
#' \dontrun{
#' GetIntAttributeFromH5("path/to/file.h5", location = , name = )
#' }
#' @export
GetIntAttributeFromH5 <- function(Filename, location, name) {
    .Call(`_TofDaqR_GetIntAttributeFromH5`, Filename, location, name)
}

#' Reads an unsigned integer attribute from the HDF5 file.
#'
#' \code{GetUintAttributeFromH5} reads an unsigned integer attribute from the
#' HDF5 file.
#'
#' Used to read attributes not available from \code{GetH5Descriptor}. Unsigned
#' integers are returned as numeric values in R.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @return An numeric attribute.
#'
#' @examples
#' \dontrun{
#' GetUintAttributeFromH5("path/to/file.h5", location = , name = )
#' }
#' @export
GetUintAttributeFromH5 <- function(Filename, location, name) {
    .Call(`_TofDaqR_GetUintAttributeFromH5`, Filename, location, name)
}

#' Reads a 64-bit integer attribute from the HDF5 file.
#'
#' \code{GetInt64AttributeFromH5} reads a 64-bit integer attribute from the
#' HDF5 file.
#'
#' Used to read attributes not available from \code{GetH5Descriptor}. int64
#' parameters are returned as string. They can be converted to integer64
#' using \code{\link[bit64:as.integer64.character]{bit64::as.integer64()}}.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @return An string attribute.
#'
#' @examples
#' \dontrun{
#' GetInt64AttributeFromH5("path/to/file.h5", location = , name = )
#' }
#' @export
GetInt64AttributeFromH5 <- function(Filename, location, name) {
    .Call(`_TofDaqR_GetInt64AttributeFromH5`, Filename, location, name)
}

#' Reads an unsigned 64-bit integer attribute from the HDF5 file.
#'
#' \code{GetUint64AttributeFromH5} reads an unsigned 64-bit integer attribute
#' from the HDF5 file.
#'
#' Used to read attributes not available from \code{GetH5Descriptor}. Unsigned
#' int64 parameters are returned as string.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @return An int64 attribute.
#'
#' @examples
#' \dontrun{
#' GetUint64AttributeFromH5("path/to/file.h5", location = , name = )
#' }
#' @export
GetUint64AttributeFromH5 <- function(Filename, location, name) {
    .Call(`_TofDaqR_GetUint64AttributeFromH5`, Filename, location, name)
}

#' Reads a float attribute from the HDF5 file.
#'
#' \code{GetFloatAttributeFromH5} reads a float attribute from the HDF5 file.
#'
#' Used to read attributes not available from \code{GetH5Descriptor}.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @return A numeric attribute.
#'
#' @examples
#' \dontrun{
#' GetFloatAttributeFromH5("path/to/file.h5", location = , name = )
#' }
#' @export
GetFloatAttributeFromH5 <- function(Filename, location, name) {
    .Call(`_TofDaqR_GetFloatAttributeFromH5`, Filename, location, name)
}

#' Reads a double attribute from the HDF5 file.
#'
#' \code{GetDoubleAttributeFromH5} reads a double attribute from the HDF5 file.
#'
#' Used to read attributes not available from \code{GetH5Descriptor}.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @return A numeric attribute.
#'
#' @examples
#' \dontrun{
#' GetDoubleAttributeFromH5("path/to/file.h5", location = , name = )
#' }
#' @export
GetDoubleAttributeFromH5 <- function(Filename, location, name) {
    .Call(`_TofDaqR_GetDoubleAttributeFromH5`, Filename, location, name)
}

#' Reads a string attribute from the HDF5 file.
#'
#' \code{GetStringAttributeFromH5} reads a string attribute from the HDF5 file.
#'
#' Used to read attributes not available from \code{GetH5Descriptor}.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @return A string attribute.
#'
#' @examples
#' \dontrun{
#' GetStringAttributeFromH5("path/to/file.h5", location = , name = )
#' }
#' @export
GetStringAttributeFromH5 <- function(Filename, location, name) {
    .Call(`_TofDaqR_GetStringAttributeFromH5`, Filename, location, name)
}

#' Writes an integer attribute to the HDF5 file.
#'
#' \code{SetIntAttributeInH5} writes an integer attribute to the HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @param attribute Integer attribute.
#'
#' @examples
#' \dontrun{
#' SetIntAttributeInH5("path/to/file.h5", location = , name = , attribute = )
#' }
#' @export
SetIntAttributeInH5 <- function(Filename, location, name, attribute) {
    invisible(.Call(`_TofDaqR_SetIntAttributeInH5`, Filename, location, name, attribute))
}

#' Writes an unsigned integer attribute to the HDF5 file.
#'
#' \code{SetUintAttributeInH5} writes an unsigned integer attribute to the HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @param attribute Unsigned integer attribute (passed as numeric value).
#'
#' @examples
#' \dontrun{
#' SetUintAttributeInH5("path/to/file.h5", location = , name = , attribute = )
#' }
#' @export
SetUintAttributeInH5 <- function(Filename, location, name, attribute) {
    invisible(.Call(`_TofDaqR_SetUintAttributeInH5`, Filename, location, name, attribute))
}

#' Writes an int64 attribute to the HDF5 file.
#'
#' \code{SetInt64AttributeInH5} writes an int64 attribute to the HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @param attribute Int64 attribute passed as a string.
#'
#' @examples
#' \dontrun{
#' SetInt64AttributeInH5("path/to/file.h5", location = , name = , attribute = )
#' }
#' @export
SetInt64AttributeInH5 <- function(Filename, location, name, attribute) {
    invisible(.Call(`_TofDaqR_SetInt64AttributeInH5`, Filename, location, name, attribute))
}

#' Writes an unsigned int64 attribute to the HDF5 file.
#'
#' \code{SetUint64AttributeInH5} writes an unsigned int64 attribute to the HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @param attribute Unsigned int64 attribute passed as a string.
#'
#' @examples
#' \dontrun{
#' SetUint64AttributeInH5("path/to/file.h5", location = , name = , attribute = )
#' }
#' @export
SetUint64AttributeInH5 <- function(Filename, location, name, attribute) {
    invisible(.Call(`_TofDaqR_SetUint64AttributeInH5`, Filename, location, name, attribute))
}

#' Writes a float attribute to the HDF5 file.
#'
#' \code{SetFloatAttributeInH5} writes a float attribute to the HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @param attribute Float attribute.
#'
#' @examples
#' \dontrun{
#' SetFloatAttributeInH5("path/to/file.h5", location = , name = , attribute = )
#' }
#' @export
SetFloatAttributeInH5 <- function(Filename, location, name, attribute) {
    invisible(.Call(`_TofDaqR_SetFloatAttributeInH5`, Filename, location, name, attribute))
}

#' Writes a double attribute to the HDF5 file.
#'
#' \code{SetDoubleAttributeInH5} writes a double attribute to the HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @param attribute Double attribute.
#'
#' @examples
#' \dontrun{
#' SetDoubleAttributeInH5("path/to/file.h5", location = , name = , attribute = )
#' }
#' @export
SetDoubleAttributeInH5 <- function(Filename, location, name, attribute) {
    invisible(.Call(`_TofDaqR_SetDoubleAttributeInH5`, Filename, location, name, attribute))
}

#' Writes a string attribute to the HDF5 file.
#'
#' \code{SetStringAttributeInH5} writes a string attribute to the HDF5 file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param name Attribute name.
#' @param attribute String attribute (max. 256 characters).
#'
#' @examples
#' \dontrun{
#' SetIntAttributeInH5("path/to/file.h5", location = , name = , attribute = )
#' }
#' @export
SetStringAttributeInH5 <- function(Filename, location, name, attribute) {
    invisible(.Call(`_TofDaqR_SetStringAttributeInH5`, Filename, location, name, attribute))
}

#' Reads user data from the HDF5 file.
#'
#' \code{GetUserDataFromH5} reads a row of user data added to the file using
#' the \code{AddUserData} function.
#'
#'  If you want to access data saved by a registered data source (or a data
#'  source plugin, which uses the same mechanism) use the \code{\link{GetRegUserDataFromH5}}
#'  function.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset where the attribute is attached to.
#' @param rowIndex Index of row to read. If index is -1 (default), all rows are read.
#' @return A list containing the user data and data description.
#'
#' @examples
#' \dontrun{
#' GetUserDataFromH5("path/to/file.h5", "/ImageData/ScanData")
#' }
#' @export
GetUserDataFromH5 <- function(Filename, location, rowIndex = -1L) {
    .Call(`_TofDaqR_GetUserDataFromH5`, Filename, location, rowIndex)
}

#' Reads a single acquisition log entry.
#'
#' \code{GetAcquisitionLogFromH5} reads a single acquisition log entry and
#' returns the timestamp and the log text.
#'
#' The timestamp is the number of 100-nanosecond intervals since January 1,
#' 1601 (UTC). Use \code{bit64::as.integer64(timestamp)} to convert the
#' timestamp string into a 64-bit integer value.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param index Index of log entry.
#' @return A list containing the timestamp (as a string) and log text.
#'
#' @examples
#' \dontrun{
#' GetAcquisitionLogFromH5("path/to/file.h5", index = )
#' }
#' @export
GetAcquisitionLogFromH5 <- function(Filename, index) {
    .Call(`_TofDaqR_GetAcquisitionLogFromH5`, Filename, index)
}

#' Reads the events of a spectrum from HDF5 data file.
#'
#' \code{GetEventListSpectrumFromH5} reads the events of a single spectrum
#' given by segment, buf and write indices from HDF5 data file.
#'
#' Note: only uncompressed event lists are supported.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param segmentIndex Segment index.
#' @param bufIndex Buf index.
#' @param writeIndex Write index.
#' @return A vector containing the event data.
#'
#' @examples
#' \dontrun{
#' GetEventListSpectrumFromH5("path/to/file.h5", segmentIndex = 0,
#' bufIndex = 0, writeIndex = 0)
#' }
#' @export
GetEventListSpectrumFromH5 <- function(Filename, segmentIndex, bufIndex, writeIndex) {
    .Call(`_TofDaqR_GetEventListSpectrumFromH5`, Filename, segmentIndex, bufIndex, writeIndex)
}

#' Gets mass calibration parameters from the data file.
#'
#' \code{H5GetMassCalibPar} gets mass calibration parameters from the data file.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param writeIndex Write index.
#' @return A list containing the calibraion mode and calibration parameters.
#'
#' @examples
#' \dontrun{
#' H5GetMassCalibPar("path/to/file.h5", writeIndex = 0)
#' }
#' @export
H5GetMassCalibPar <- function(Filename, writeIndex) {
    .Call(`_TofDaqR_H5GetMassCalibPar`, Filename, writeIndex)
}

#' Adds an entry to an existing data file.
#'
#' \code{H5AddLogEntry} adds an entry to an existing data file. To add
#' acquisition log entries during a running acquisition use \code{AddLogEntry}.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param LogEntryText Log text (max. 255 characters).
#' @param LogEntryTime Log entry time (number of 100-nanosecond intervals since
#' January 1, 1601 UTC, Windows FILETIME) passed as a string. Set it to "0" for
#' "now".
#'
#' @export
H5AddLogEntry <- function(Filename, LogEntryText, LogEntryTime) {
    invisible(.Call(`_TofDaqR_H5AddLogEntry`, Filename, LogEntryText, LogEntryTime))
}

#' Adds user data to a data file.
#'
#' \code{H5AddUserDataMultiRow} adds user data to a data file. Creates datasets
#' "Data" and "Info" at \code{Location}.
#'
#' @param filename Path/filename of the HDF5 file.
#' @param location Location of group in HDF5 file where the datasets are created.
#' @param nbrElements Number of elements to store per row (if the dataset
#' already exists this value must be the same as in the file).
#' @param nbrRows Number of rows to store per call to this function (each row
#' contains \code{NbrElements} entries).
#' @param data Vector of length \code{nbrElements*nbrRows} containing the data to be
#' stored in dataset "Data".
#' @param elementDescription Vector of length \code{nbrElements} containing the
#' text description of elements. If \code{ElementDescription} is \code{NULL}
#' the dataset "Info" is not created.
#' @param compressionLevel ZLIB compression level (0-9) for dataset creation.
#' If the dataset at Location already exists this parameter has no effect.
#'
#' @export
H5AddUserDataMultiRow <- function(filename, location, nbrElements, nbrRows, data, elementDescription = NULL, compressionLevel = 0L) {
    invisible(.Call(`_TofDaqR_H5AddUserDataMultiRow`, filename, location, nbrElements, nbrRows, data, elementDescription, compressionLevel))
}

#' Deletes an attribute.
#'
#' \code{DeleteAttributeInH5} deletes an attribute.
#'
#' WARNING: no sanity checking is performed! You can delete attributes that
#' render the data file unusable.
#'
#' @param filename Path/filename of the HDF5 file.
#' @param location Location of the group or dataset the attribute is deleted from.
#' @param name Attribute name.
#'
#' @export
DeleteAttributeInH5 <- function(filename, location, name) {
    invisible(.Call(`_TofDaqR_DeleteAttributeInH5`, filename, location, name))
}

#' Checks whether a file can be opened with exclusive access rights.
#'
#' \code{WaitForExclusiveFileAccess} checks whether a file can be opened with
#' exclusive access rights. This function can be used when opening a data file
#' that just finished recording in order to make sure that the recording
#' application as well as the OS have finished writing to the file. Available
#' only under Windows, returns TwError on other platforms.
#'
#' @param filename Path/filename of the HDF5 file.
#' @param timeoutMs Timeout (in ms) after which the function returns.
#'
#' @export
WaitForExclusiveFileAccess <- function(filename, timeoutMs) {
    invisible(.Call(`_TofDaqR_WaitForExclusiveFileAccess`, filename, timeoutMs))
}

#' Writes a ANDI chromatography file.
#'
#' \code{WriteNetCdfTimeSeriesFile} writes a ANDI chromatography file.
#'
#' @param filename Path/filename of the HDF5 file.
#' @param inject_ts Injection timestamp (number of 100-nanosecond intervals since
#' January 1, 1601 UTC, Windows FILETIME) passed as a string.
#' @param expTitle Experiment title.
#' @param operator_name Operator name.
#' @param company_method_name Company method name.
#' @param source_file_reference Source file reference.
#' @param retention_unit Retention unit, e.g. "[s]".
#' @param detector_unit Detector unit, e.g. "[cps]".
#' @param sample_name Sample name.
#' @param raw_data_table_name Dataset name.
#' @param retention Time axis data.
#' @param ordinate Intensity axis data.
#'
#' @export
WriteNetCdfTimeSeriesFile <- function(filename, inject_ts, expTitle, operator_name, company_method_name, source_file_reference, retention_unit, detector_unit, sample_name, raw_data_table_name, retention, ordinate) {
    invisible(.Call(`_TofDaqR_WriteNetCdfTimeSeriesFile`, filename, inject_ts, expTitle, operator_name, company_method_name, source_file_reference, retention_unit, detector_unit, sample_name, raw_data_table_name, retention, ordinate))
}

#' Changes the global mass calibration in the data file.
#'
#' \code{H5SetMassCalib} changes the global mass calibration in the data file.
#' If \code{nbrParams} is 0, the calibration parameters will be determined from
#' \code{mass}, \code{tof} and \code{weight}. If calibration parameters and
#' calibration points are provided, the calibration is given by the parameters
#' (no sanity check is performed whether the points yield the same parameters).
#'
#' \tabular{cl}{
#' mode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param mode Mass calibration function to use.
#' @param nbrParams Number of mass calibration parameters.
#' @param p Vector with mass calibration parameters.
#' @param mass Vector with mass of the calibration points.
#' @param tof Vector with TOF sample index of the calibration points.
#' @param weight Vector with weight of the calibration points.
#'
#' @export
H5SetMassCalib <- function(Filename, mode, nbrParams, p, mass, tof, weight) {
    invisible(.Call(`_TofDaqR_H5SetMassCalib`, Filename, mode, nbrParams, p, mass, tof, weight))
}

#' Changes the global mass calibration in the data file.
#'
#' \code{H5SetMassCalib2} changes the global mass calibration in the data file.
#' If \code{nbrParams} is 0, the calibration parameters will be determined from
#' \code{mass}, \code{tof} and \code{weight}. If calibration parameters and
#' calibration points are provided, the calibration is given by the parameters
#' (no sanity check is performed whether the points yield the same parameters).
#'
#' \tabular{cl}{
#' mode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param mode Mass calibration function to use.
#' @param nbrParams Number of mass calibration parameters.
#' @param p Vector with mass calibration parameters.
#' @param mass Vector with mass of the calibration points.
#' @param tof Vector with TOF sample index of the calibration points.
#' @param weight Vector with weight of the calibration points.
#'
#' @export
H5SetMassCalib2 <- function(Filename, mode, nbrParams, p, mass, tof, weight) {
    invisible(.Call(`_TofDaqR_H5SetMassCalib2`, Filename, mode, nbrParams, p, mass, tof, weight))
}

#' Changes the global mass calibration in the data file.
#'
#' \code{H5SetMassCalibEx} changes the global mass calibration in the data file.
#' If \code{nbrParams} is 0, the calibration parameters will be determined from
#' \code{mass}, \code{tof} and \code{weight}. If calibration parameters and
#' calibration points are provided, the calibration is given by the parameters
#' (no sanity check is performed whether the points yield the same parameters).
#' Labels to identify compound names/formulas used for calibration have a
#' maximum length of 255 characters.
#'
#' \tabular{cl}{
#' mode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param mode Mass calibration function to use.
#' @param nbrParams Number of mass calibration parameters.
#' @param p Vector with mass calibration parameters.
#' @param mass Vector with mass of the calibration points.
#' @param tof Vector with TOF sample index of the calibration points.
#' @param weight Vector with weight of the calibration points.
#' @param label Vector with labels/names/sum formula of the calibration points.
#'
#' @export
H5SetMassCalibEx <- function(Filename, mode, nbrParams, p, mass, tof, weight, label) {
    invisible(.Call(`_TofDaqR_H5SetMassCalibEx`, Filename, mode, nbrParams, p, mass, tof, weight, label))
}

#' Changes the global mass calibration in the data file.
#'
#' \code{H5SetMassCalib2Ex} changes the global mass calibration in the data file.
#' If \code{nbrParams} is 0, the calibration parameters will be determined from
#' \code{mass}, \code{tof} and \code{weight}. If calibration parameters and
#' calibration points are provided, the calibration is given by the parameters
#' (no sanity check is performed whether the points yield the same parameters).
#' Labels to identify compound names/formulas used for calibration have a
#' maximum length of 255 characters.
#'
#' \tabular{cl}{
#' mode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param mode Mass calibration function to use.
#' @param nbrParams Number of mass calibration parameters.
#' @param p Vector with mass calibration parameters.
#' @param mass Vector with mass of the calibration points.
#' @param tof Vector with TOF sample index of the calibration points.
#' @param weight Vector with weight of the calibration points.
#' @param label Vector with labels/names/sum formula of the calibration points.
#'
#' @export
H5SetMassCalib2Ex <- function(Filename, mode, nbrParams, p, mass, tof, weight, label) {
    invisible(.Call(`_TofDaqR_H5SetMassCalib2Ex`, Filename, mode, nbrParams, p, mass, tof, weight, label))
}

#' Stores dynamic mass calibration for a given spectrum in the data file.
#'
#' \code{H5SetMassCalibDynamic} stores dynamic mass calibration for a given
#' spectrum in the data file.
#'
#' This function can be used to delete the dynamic calibration information by
#' passing the special parameter set: \code{writeIndex} = -1, \code{nbrParams}
#' = \code{nbrStat} = 0 and \code{par} = \code{stat} = \code{NULL}. With the
#' \code{stat} array additional information can be stored in the dataset
#' \code{/FullSpectra/MassCalibrationStats} (no official format definition or
#' supporting API functions).
#'
#' @param filename Path/filename of the HDF5 file.
#' @param writeIndex Write index of the calibration to store.
#' @param par Numeric vector holding the actual calibration values.
#' @param stat Numeric vector with additional information on how the parameters
#' were obtained (typically).
#'
#' @export
H5SetMassCalibDynamic <- function(filename, writeIndex, par, stat) {
    invisible(.Call(`_TofDaqR_H5SetMassCalibDynamic`, filename, writeIndex, par, stat))
}

#' Changes the PeakTable and recomputes the PeakData.
#'
#' \code{ChangePeakTable} changes the entries in the dataset \code{/PeakData/PeakTable}
#' and recomputes \code{/PeakData/PeakData} accordingly.
#'
#' Depending on data file size recomputing the peak data can take a long time.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param PeakPar List with the new peak paramters \emph{label}, \emph{mass},
#' \emph{loMass} and \emph{hiMass}.
#' @param compressionLevel Compression Level (1..9).
#'
#' @export
ChangePeakTable <- function(Filename, PeakPar, compressionLevel) {
    invisible(.Call(`_TofDaqR_ChangePeakTable`, Filename, PeakPar, compressionLevel))
}

#' Changes the PeakTable and recomputes the PeakData.
#'
#' \code{ChangePeakTableFromFile} changes the entries in the dataset \code{/PeakData/PeakTable}
#' and recomputes \code{/PeakData/PeakData} accordingly. This is a convenience
#' function for \code{\link{ChangePeakTable}}. Instead of specifiying directly
#' peak parameters the information is taken from a mass table (text file) or a
#' Tofwerk HDF5 file.
#'
#' Depending on data file size  recomputing the peak data can take a long time.
#'
#' @param Filename Path/filename of the HDF5 file.
#' @param massTable Path/filename to mass table or HDF5 file.
#' @param compressionLevel Compression Level (1..9).
#'
#' @export
ChangePeakTableFromFile <- function(Filename, massTable, compressionLevel) {
    invisible(.Call(`_TofDaqR_ChangePeakTableFromFile`, Filename, massTable, compressionLevel))
}

#' Performs a peak fit.
#'
#' \code{FitSinglePeak} performs a peak fit. Gaussian, Lorentzian and
#' Pseudo-Voigt peak shapes are supported.
#'
#' Peak parameters are optimized using a Levenberg-Marquardt algorithm as
#' implemented by the library \code{lmfit}. The following peak types are available:
#' \tabular{cccc}{
#' peak type index \tab peak function \tab symmetric \tab baseline \cr
#' -1 \tab Gaussian through highest point and its neighbours \tab yes \tab no \cr
#' 0 \tab Gaussian \tab yes \tab no  \cr
#' 1 \tab Lorentzian \tab yes \tab no \cr
#' 2 \tab Pseudo-Voigt \tab yes \tab no \cr
#' 3 \tab Gaussian \tab yes \tab yes \cr
#' 4 \tab Lorentzian \tab yes \tab yes \cr
#' 5 \tab Pseudo-Voigt \tab yes \tab yes \cr
#' 6 \tab Gaussian \tab no \tab no \cr
#' 7 \tab Lorentzian \tab no \tab no \cr
#' 8 \tab Pseudo-Voigt \tab no \tab no \cr
#' 9 \tab Gaussian \tab no \tab yes \cr
#' 10 \tab Lorentzian \tab no \tab yes \cr
#' 11 \tab Pseudo-Voigt \tab no \tab yes
#' } The function for peakType = -1 is not an actual peak fit but rather the
#' Gaussian function (symmetric, no baseline) defined by the maximum intensity
#' point and its neighbors. It is used to automatically generate guess values
#' for position, width and amplitude if all peak parameters are set to 0.
#'
#' @param yVals y axis data.
#' @param xVals x axis data.
#' @param peakType peak model to use.
#' @param blOffset Initial value of baseline offset at first data point.
#' @param blSlope Initial value of slope of baseline.
#' @param amplitude Initial value of peak amplitude.
#' @param fwhmLo Initial value of left peak width (full width at half maximum).
#' @param fwhmHi Initial value of right peak width (full width at half maximum).
#' @param peakPos Initial value of peak position.
#' @param mu Initial value of Gaussian/Lorentzian contribution.
#' @return List with peak parameters.
#'
#' @family Peak fitting functions
#' @export
FitSinglePeak <- function(yVals, xVals, peakType = 0L, blOffset = 0, blSlope = 0, amplitude = 0, fwhmLo = 0, fwhmHi = 0, peakPos = 0, mu = 0) {
    .Call(`_TofDaqR_FitSinglePeak`, yVals, xVals, peakType, blOffset, blSlope, amplitude, fwhmLo, fwhmHi, peakPos, mu)
}

#' Performs a peak fit (Initial values as vector).
#'
#' \code{FitSinglePeak2} performs a peak fit. Gaussian, Lorentzian and
#' Pseudo-Voigt peak shapes are supported.
#'
#' Same as \code{\link{FitSinglePeak}}, but takes the initial values of the
#' fit parameter as a vector argument instead of explicit parameters.
#' Peak parameters are optimized using a Levenberg-Marquardt algorithm as
#' implemented by the library \code{lmfit}. The following peak types are available:
#' \tabular{cccc}{
#' peak type index \tab peak function \tab symmetric \tab baseline \cr
#' -1 \tab Gaussian through highest point and its neighbours \tab yes \tab no \cr
#' 0 \tab Gaussian \tab yes \tab no  \cr
#' 1 \tab Lorentzian \tab yes \tab no \cr
#' 2 \tab Pseudo-Voigt \tab yes \tab no \cr
#' 3 \tab Gaussian \tab yes \tab yes \cr
#' 4 \tab Lorentzian \tab yes \tab yes \cr
#' 5 \tab Pseudo-Voigt \tab yes \tab yes \cr
#' 6 \tab Gaussian \tab no \tab no \cr
#' 7 \tab Lorentzian \tab no \tab no \cr
#' 8 \tab Pseudo-Voigt \tab no \tab no \cr
#' 9 \tab Gaussian \tab no \tab yes \cr
#' 10 \tab Lorentzian \tab no \tab yes \cr
#' 11 \tab Pseudo-Voigt \tab no \tab yes
#' } The function for peakType = -1 is not an actual peak fit but rather the
#' Gaussian function (symmetric, no baseline) defined by the maximum intensity
#' point and its neighbors. It is used to automatically generate guess values
#' for position, width and amplitude if all peak parameters are set to 0.
#'
#' @param yVals y axis data.
#' @param xVals x axis data.
#' @param peakType peak model to use.
#' @param param Vector of initial values (blOffset, blSlope, amplitude, fwhmLo,
#' fwhmHi, peakPos, mu).
#' @return List with peak parameters.
#'
#' @family Peak fitting functions
#' @export
FitSinglePeak2 <- function(yVals, xVals, peakType = 0L, param = as.numeric( c(0,0,0,0,0,0,0))) {
    .Call(`_TofDaqR_FitSinglePeak2`, yVals, xVals, peakType, param)
}

#' Calculates the y-axis values for a given set of peak parameters.
#'
#' \code{EvalSinglePeak} calculates the y-axis values for a given set of peak
#' parameters.
#'
#' @param xVals x axis data.
#' @param blOffset Baseline offset at first data point.
#' @param blSlope Slope of baseline.
#' @param amplitude Peak amplitude.
#' @param fwhmLo Left peak width (full width at half maximum).
#' @param fwhmHi Right peak width (full width at half maximum).
#' @param peakPos Peak position.
#' @param mu Gaussian/Lorentzian contribution.
#' @return Vector with y axis data.
#'
#' @family Peak fitting functions
#' @export
EvalSinglePeak <- function(xVals, blOffset = 0, blSlope = 0, amplitude = 0, fwhmLo = 0, fwhmHi = 0, peakPos = 0, mu = 0) {
    .Call(`_TofDaqR_EvalSinglePeak`, xVals, blOffset, blSlope, amplitude, fwhmLo, fwhmHi, peakPos, mu)
}

#' Calculates the mass/charge ratio of a molecule.
#'
#' \code{GetMoleculeMass} parses the molecular formula and returns the
#' mass/charge ratio of the molecule/atom/ion.
#'
#' The formula parser for the molecule string understands the (case sensitive)
#' element labels and round and curly brackets (square brackets are reserved for
#' isotope specification). Numbers (multipliers) have to follow either directly
#' the element symbol or a closing bracket. Specific isoptopes are specified in
#' square brackets with the mass number before the element label (e.g. [2H],
#' [14C] or [235U]). Charge indicators (+, -) have to be the last characters in
#' the formula string, multiple charges require multiple charge symbols (e.g.
#' doubly charged calcium is Ca++ and not Ca2+ which is the correct syntax for a
#' singly charged calcium dimer).
#'
#' @param molecule Molecule string.
#' @return Mass/charge ratio.
#'
#' @family Chemistry functions
#'
#' @examples
#' GetMoleculeMass("CO2")
#' GetMoleculeMass("CO2++")
#' GetMoleculeMass("[13C]O2+")
#' GetMoleculeMass("[13C][18O]2")
#' @export
GetMoleculeMass <- function(molecule) {
    .Call(`_TofDaqR_GetMoleculeMass`, molecule)
}

#' Performs a multi-peak fit.
#'
#' \code{MultiPeakFit} performs a multi-peak fit for (partially) overlapping
#' peaks. All peaks in a multi-peak cluster share common peak parameters except
#' amplitude and position. Various options allow for a more or less constrained
#' fit (see description of options below).
#'
#' The peak positions are not optimized, but the common mass shift parameter in
#' \code{commonPar} allows for minimal refinement of the peak positions due to
#' imperfect mass calibration.
#'
#' \code{options} is a list containing:
#' \tabular{rcl}{
#' peakModel \tab = \tab 0 (Gauss) or 1 (Lorentz) or 2 (Pseudo-Voigt) \cr
#' asymmetric \tab = \tab 0 (symmetric peak model) or 1 (asymmetric peak model) \cr
#' baseline \tab = \tab 0 (no optimization of baseline parameters) or 1 (optimize baseline parameters) \cr
#' width \tab = \tab 0 (no optimization of width parameters) or 1 (optimize width parameters) \cr
#' peakShape \tab = \tab 0 (no optimization of peak shape (mu) parameter) or 1 (optimize peak shape (mu) parameter (applies only to pseudo-Voigt)) \cr
#' massShift \tab = \tab 0 (no optimization of common mass shift parameters) or 1 (optimize common mass shift parameters) \cr
#' amplitude \tab = \tab 0 (no constraint on amplitudes) or 1 (constrain sum of baseline and all peaks to total intensity in spectrum)
#' } Note that if a given parameter is not activated for optimization, the
#' supplied (guess) values are still used (e.g. specify a known baseline
#' without optimizing the parameters).
#'
#' @param dataX x axis data.
#' @param dataY y axis data.
#' @param mass  Vector of the known positions of the peaks.
#' @param intensity  Vector of initial guesses for intensities. If all values
#' are 0 the guess values for peak intensities are generated automatically.
#' @param commonPar Vector of guess values of common peak parameters. \code{commonPar}
#' has 6 elements: [1] offset of common baseline, [2] slope of common baseline,
#' [3] left FWHM, [4] right FWHM (same as left FWHM for symmetric peaks),
#' [5] shape parameter mu (applies only for peak model Pseudo-Voigt),
#' [6] common mass shift of peaks. \code{options} determines which of the
#' common parameters are optimized.
#' @param options List of peak model and optimization options (see Details).
#'
#' @return List with the optimized intensities and common peak parameters.
#'
#' @family Peak fitting functions
#' @export
MultiPeakFit <- function(dataX, dataY, mass, intensity, commonPar, options) {
    .Call(`_TofDaqR_MultiPeakFit`, dataX, dataY, mass, intensity, commonPar, options)
}

#' Calculates the y-axis values for a given set of multi-peak parameters.
#'
#' \code{EvalMultiPeak} calculates the y-axis values for a given set of
#' multi-peak parameters.
#'
#' @param dataX x axis data.
#' @param mass  Vector of the peak positions.
#' @param intensity  Vector of (fitted) intensities.
#' @param commonPar Vector of (fitted) values of common peak parameters. \code{commonPar}
#' has 6 elements: [1] offset of common baseline, [2] slope of common baseline,
#' [3] left FWHM, [4] right FWHM, [5] shape parameter mu,
#' [6] common mass shift of peaks.
#'
#' @return Vector with y axis data.
#'
#' @family Peak fitting functions
#' @export
EvalMultiPeak <- function(dataX, mass, intensity, commonPar) {
    .Call(`_TofDaqR_EvalMultiPeak`, dataX, mass, intensity, commonPar)
}

#' Fits mass versus resolution values to an empirical function.
#'
#' \code{FitResolution} fits mass versus resolution values to an empirical
#' function (see Details).
#'
#' An empirical function that describes the mass resolution as a function of
#' mass is: R(m) = R0 - R0/(1 + exp((m -m0)/dm)), where R0 is the nominal mass
#' resolution, m0 is the mass at which the resolution is R0/2 and dm is a slope
#' parameter.
#'
#' Reasonable initial guess values for R0, m0 and dm need to be provided.
#'
#' @param mass Vector of mass values.
#' @param resolution Vector of resolution values.
#' @param R0 Initial guess value of nominal mass resolution R0.
#' @param m0 Initial guess value of m0 (mass where R(m) = 0.5*R0).
#' @param dm Initial guess value of slope parameter dm.
#' @return List with the fitted parameters R0, m0 and dm.
#'
#' @seealso \code{\link{EvalResolution}}
#'
#' @export
FitResolution <- function(mass, resolution, R0, m0, dm) {
    .Call(`_TofDaqR_FitResolution`, mass, resolution, R0, m0, dm)
}

#' Evaluates the fitted resolution function for given mass values.
#'
#' \code{EvalResolution} evaluates the fitted resolution function for given
#' mass values.
#'
#' An empirical function that describes the mass resolution of TOFs as a
#' function of mass is: R(m) = R0 - R0/(1 + exp((m -m0)/dm)), where
#' R0 is the nominal mass resolution, m0 is the mass at which the resolution
#' is R0/2 and dm is a slope parameter.
#'
#' @param R0 Nominal mass resolution.
#' @param m0 Mass where R(m) = 0.5*R0.
#' @param dm Slope parameter.
#' @param mass Vector of mass values.
#' @return Vector with resolution values.
#'
#' @seealso \code{\link{FitResolution}}
#'
#' @export
EvalResolution <- function(R0, m0, dm, mass) {
    .Call(`_TofDaqR_EvalResolution`, R0, m0, dm, mass)
}

#' Calculates the isotope pattern of a molecule.
#'
#' \code{GetIsotopePattern} parses the molecular formula and returns the
#' isotope pattern (mass and abundance).
#'
#' The formula parser for the molecule string understands the (case sensitive)
#' element labels and round and curly brackets (square brackets are reserved for
#' isotope specification). Numbers (multipliers) have to follow either directly
#' the element symbol or a closing bracket. Specific isoptopes are specified in
#' square brackets with the mass number before the element label (e.g. [2H],
#' [14C] or [235U]). Charge indicators (+, -) have to be the last characters in
#' the formula string, multiple charges require multiple charge symbols (e.g.
#' doubly charged calcium is Ca++ and not Ca2+ which is the correct syntax for a
#' singly charged calcium dimer).
#'
#' @param molecule Molecule string.
#' @param abundanceLimit Absolute abundance limit for the generated pattern.
#' @return List with mass and abundace vectors.
#'
#' @family Chemistry functions
#'
#' @examples
#' GetIsotopePattern("CO2", 1e-5)
#' @export
GetIsotopePattern <- function(molecule, abundanceLimit) {
    .Call(`_TofDaqR_GetIsotopePattern`, molecule, abundanceLimit)
}

#' Calculates the isotope pattern of a molecule.
#'
#' \code{GetIsotopePattern2} parses the molecular formula and returns the
#' isotope pattern (mass and abundance).
#'
#' Same as \code{GetIsotopePattern} but using an exact algorithm and is
#' therefore suitable only for rather small molecules.
#'
#' The formula parser for the molecule string understands the (case sensitive)
#' element labels and round and curly brackets (square brackets are reserved for
#' isotope specification). Numbers (multipliers) have to follow either directly
#' the element symbol or a closing bracket. Specific isoptopes are specified in
#' square brackets with the mass number before the element label (e.g. [2H],
#' [14C] or [235U]). Charge indicators (+, -) have to be the last characters in
#' the formula string, multiple charges require multiple charge symbols (e.g.
#' doubly charged calcium is Ca++ and not Ca2+ which is the correct syntax for a
#' singly charged calcium dimer).
#'
#' @param molecule Molecule string.
#' @param abundanceLimit Absolute abundance limit for the generated pattern.
#' @return List with mass and abundace vectors.
#'
#' @family Chemistry functions
#'
#' @examples
#' GetIsotopePattern2("CO2", 1e-5)
#' @export
GetIsotopePattern2 <- function(molecule, abundanceLimit) {
    .Call(`_TofDaqR_GetIsotopePattern2`, molecule, abundanceLimit)
}

#' Converts from sample index to mass/charge.
#'
#' \code{Tof2Mass} converts from sample index to mass/charge.
#'
#' \tabular{cl}{
#' massCalibMode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param tofSample Vector of sample indices to convert.
#' @param massCalibMode Mass calibration function to use. See below.
#' @param p Vector containing the calibration parameters (number depends on
#' \code{MassCalibMode}, see below).
#' @return Mass/charge values.
#'
#' @seealso \code{\link{Mass2Tof}}
#'
#' @examples
#' Tof2Mass(100000, massCalibMode = 0, p = c(3,5))
#' @export
Tof2Mass <- function(tofSample, massCalibMode, p) {
    .Call(`_TofDaqR_Tof2Mass`, tofSample, massCalibMode, p)
}

#' Converts from mass/charge to sample index.
#'
#' \code{Mass2Tof} converts from mass/charge to sample index.
#'
#' \tabular{cl}{
#' massCalibMode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param mass Vector of mass/charge values to convert.
#' @param massCalibMode Mass calibration function to use. See below.
#' @param p Vector containing the calibration parameters (number depends on
#' \code{MassCalibMode}, see below).
#' @return Sample indices.
#'
#' @seealso \code{\link{Tof2Mass}}
#'
#' @examples
#' Mass2Tof(100, massCalibMode = 0, p = c(3,5))
#' @export
Mass2Tof <- function(mass, massCalibMode, p) {
    .Call(`_TofDaqR_Mass2Tof`, mass, massCalibMode, p)
}

#'  Performs a mass calibration.
#'
#' \code{MassCalibrate} performs a mass calibration for a list of
#' mass/sample index/weight values and for a given calibration mode.
#'
#' \tabular{cl}{
#' massCalibMode \tab Mass calibration function \cr
#' 0 \tab \eqn{i = p_1 \sqrt(m) + p_2} \cr
#' 1 \tab \eqn{i = p_1/\sqrt(m) + p_2} \cr
#' 2 \tab \eqn{i = p_1 m^{p_3} + p_2} \cr
#' 3 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 (m - p_4)^2} \cr
#' 4 \tab \eqn{i = p_1 \sqrt(m) + p_2 + p_3 m^2 + p_4 m + p_5} \cr
#' 5 \tab \eqn{m = p_1 i^2 + p_2 i + p_3}
#' }
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param massCalibMode Mass calibration function to use. See below.
#' @param mass Vector of mass/charge values.
#' @param tof Vector of sample indices (of same length as \code{mass}).
#' @param weight Vector of weights (if \code{NULL} (default) all weights are set equal).
#' @return Vector of calibration parameters.
#' @export
MassCalibrate <- function(massCalibMode, mass, tof, weight = NULL) {
    .Call(`_TofDaqR_MassCalibrate`, massCalibMode, mass, tof, weight)
}

#' Gets the description and number of parameters of the available mass
#' calibration functions.
#'
#' \code{GetMassCalibInfo} gets the description and number of parameters of the
#' available mass calibration functions.
#'
#' Note: Modes 3 and 4 are flawed. Don't use them. In mode 3 the fit does not
#' converge well, because of a bug (parameters not correctly initialized).
#' Mode 4 is two sequential fits, first mode 0, then a quadratic fit to the
#' residuals, which is an inferior implementation of mode 3. Mode 1 is for FTMS
#' data.
#'
#' @param massCalibMode Mass calibration mode (0 to 5).
#' @return List with the description and number of calibration parameters for
#' the given \code{massCalibMode}.
#' @export
GetMassCalibInfo <- function(massCalibMode) {
    .Call(`_TofDaqR_GetMassCalibInfo`, massCalibMode)
}

#' Initializes the single ion histogramming.
#'
#' \code{SiInitializeHistograms} initializes the single ion histogramming.
#'
#' This function must be called before calling the functions
#' \code{\link{SiSetProcessingOptions}}, \code{\link{SiProcessSpectrum}}, \code{\link{SiGetHistogram}},
#' \code{\link{SiResetHistograms}} or \code{\link{SiCleanup}}. Each mass range specified by
#' \code{loMass} and \code{hiMass} elements is associated with a spectrum type that allows to
#' get separate statistics for multi-spectrum acquisitions (bipolar or pulsed
#' experiments).
#'
#' @param loMass Vector of the lower borders of the mass ranges.
#' @param hiMass Vector of the upper borders of the mass ranges.
#' @param specType Vector of spectrum type indices (non-negative integers). If
#' specType is \code{NULL}, all mass ranges get a default spectrum type of 0.
#'
#' @family Single ion histogramming functions
#' @export
SiInitializeHistograms <- function(loMass, hiMass, specType = NULL) {
    invisible(.Call(`_TofDaqR_SiInitializeHistograms`, loMass, hiMass, specType))
}

#' Sets processing options for each spectrum type.
#'
#' \code{SiSetProcessingOptions} sets processing options for each spectrum type.
#'
#' Options:
#' \tabular{llc}{
#' Name \tab Description \tab Default value \cr
#' \code{MassCalibMode} \tab Mass calibration mode in use (see \code{\link{MassCalibrate}}). \tab 0 \cr
#' \code{MassCalibParamn} \tab Mass calibration parameters n =
#' 1..number of calibration parameters for the given mass calibration mode. \tab \code{c(1000, 0)} \cr
#' \code{FullScale} \tab Full digitizing range of the ADC in the same units as
#' the spectra to be analyzed (typically mV). \tab 500 \cr
#' \code{NbrBits} \tab ADC resolution (8 for AP240, 14 for ADQ114 etc.). \tab 8 \cr
#' \code{SampleInterval} \tab Sample interval in ns. \tab 1 \cr
#' \code{PreampGain} \tab Gain of external preamp. \tab 1 \cr
#' \code{PreSamples} \tab Number of samples before a threshold crosser taken into account. \tab 0 \cr
#' \code{PostSamples} \tab Number of samples after a negative threshold crosser taken into account. \tab 0 \cr
#' \code{BaselineAndThresholdFromData} \tab If >0 the baseline and threshold
#' values will be determined based on \code{NbrStdDevs} for every processed
#' spectrum. If >1.5 baseline noise is determined from a fit to a histogram of
#' all data (instead of from the standard deviation of all data). This makes the
#' noise determination more robust when real peaks are present in the spectrum. \tab 0 \cr
#' \code{NbrStdDevs} \tab Number of standard deviations of baseline noise that
#' defines the threshold. Only relevant if \code{BaselineAndThresholdFromData>0}. \tab 6 \cr
#' \code{Baseline} \tab Baseline value used for calculation of intensities. Has
#' no meaning if \code{BaselineAndThresholdFromData>0}. \tab 5 \cr
#' \code{Threshold} \tab Threshold value used for calculation of intensities.
#' Has no meaning if \code{BaselineAndThresholdFromData!=0}. \tab 8 \cr
#' \code{NegativeSignal} \tab Indicates peak polarity with respect to the baseline. \tab 0 (=FALSE) \cr
#' \code{BaselineAndThresholdInCodes} \tab Indicates whether the values in \code{Baseline}
#' and \code{Threshold} are interpreted as ADC codes or mV. \tab 1 (=TRUE)
#' }
#'
#' @param option Option to set (see below for a list of valid option strings).
#' @param value Value to set the for the given option.
#' @param specType Spectrum type index. -1 is a wildcard for all spectrum types.
#'
#' @family Single ion histogramming functions
#' @export
SiSetProcessingOptions <- function(option, value, specType) {
    invisible(.Call(`_TofDaqR_SiSetProcessingOptions`, option, value, specType))
}

#' Processes a spectrum.
#'
#' \code{SiProcessSpectrum} processes a spectrum according to the options set for
#' it's spectrum type.
#'
#' See \code{\link{SiProcessSpectrumFromShMem}} for another variant of this
#' function, where the spectrum is directly read from shared memory.
#'
#' @param spectrum Vector holding the spectrum to process.
#' @param specType Spectrum type index (non-negative integer).
#' @return A list with the baseline and threshold value.
#'
#' @family Single ion histogramming functions
#' @export
SiProcessSpectrum <- function(spectrum, specType) {
    .Call(`_TofDaqR_SiProcessSpectrum`, spectrum, specType)
}

#' Gets a histogram of the single ion intensities.
#'
#' \code{SiGetHistogram} gets a histogram of the single ion intensities for a
#' mass range defined with \code{\link{SiInitializeHistograms}}.
#'
#' Note: R crashes if \code{histogramIndex} is set to max(histogramIndex)+1
#' (API bug).
#'
#' @param histogramIndex Index (zero-based numbering) of the histogram. It
#' corresponds to the mass range defined with \code{\link{SiInitializeHistograms}}.
#' @return A list with the intensities (histogram x-values), counts (histogram
#' y-values), the number of spectra that were processed for this histogram and
#' the mean histogram value i.e. sum(intensity[i]*counts[i])/sum(counts[i]).
#'
#' @family Single ion histogramming functions
#' @export
SiGetHistogram <- function(histogramIndex) {
    .Call(`_TofDaqR_SiGetHistogram`, histogramIndex)
}

#' Gets a sum histogram of the single ion intensities.
#'
#' \code{SiGetSumHistogram} gets a histogram of the single ion intensities, which
#' is a sum over all histograms of a given \code{specType} within the rate and
#' mass range as specified by \code{minMass}, \code{maxMass}, \code{minRate} and \code{maxRate}.
#'
#' @param specType Spectrum type index (non-negative integer).
#' @param minMass Minimum mass for histogram filtering.
#' @param maxMass Maximum mass for histogram filtering.
#' @param minRate Minimum event count rate for histogram filtering.
#' @param maxRate Maximum event count rate for histogram filtering.
#' @return A list with the intensities (histogram x-values), counts (histogram
#' y-values), the number of spectra that were processed for this histogram and
#' the mean histogram value i.e. sum(intensity[i]*counts[i])/sum(counts[i]).
#'
#' @family Single ion histogramming functions
#' @export
SiGetSumHistogram <- function(specType, minMass, maxMass, minRate, maxRate) {
    .Call(`_TofDaqR_SiGetSumHistogram`, specType, minMass, maxMass, minRate, maxRate)
}

#' Resets all histograms and spectrum counters to zero.
#'
#' \code{SiResetHistograms} resets all histograms and spectrum counters to zero.
#'
#' @family Single ion histogramming functions
#' @export
SiResetHistograms <- function() {
    invisible(.Call(`_TofDaqR_SiResetHistograms`))
}

#' Cleans up the state in the DLL.
#'
#' \code{SiCleanup} cleans up the state in the DLL. After a call to this
#' function \code{\link{SiInitializeHistograms}} can be called again.
#'
#' @family Single ion histogramming functions
#' @export
SiCleanup <- function() {
    invisible(.Call(`_TofDaqR_SiCleanup`))
}

#' Fits a (slightly modified) log-normal distribution to the histogram.
#'
#' \code{SiFitPhd} fits a (slightly modified) log-normal distribution to the
#' histogram data.
#'
#' The following equation with the parameters A, w, x0 and xc is fitted: \cr
#' \eqn{A/(\sqrt(2*pi)*w*(x-x0))*exp(-(log((x-x0)/xc)^2)/(2*w^2))}
#'
#' @param intensity Vector of intensities (histogram x-axis data).
#' @param counts Vector of counts (histogram y-axis data).
#' @return A list with the FWHM of the distribution, the position of the fitted
#' maximum and a vector with the values of the four fitting parameters.
#'
#' @family Single ion histogramming functions
#' @export
SiFitPhd <- function(intensity, counts) {
    .Call(`_TofDaqR_SiFitPhd`, intensity, counts)
}

#' Evaluates the fitted single ion distribution.
#'
#' \code{SiEvalPhd} evaluates the fitted single ion distribution.
#'
#' @param par Vector of fitted parameter values.
#' @param intensity Vector of intensities (histogram x-axis data).
#' @return Vector with y-axis data.
#'
#' @family Single ion histogramming functions
#' @export
SiEvalPhd <- function(par, intensity) {
    .Call(`_TofDaqR_SiEvalPhd`, par, intensity)
}

#' Fits an event rate to a multi-ion histogram.
#'
#' \code{SiFitRateFromPhd} takes a fitted single ion distribution as input
#' and fits an event rate to a multi-ion histogram (intensity and counts)
#' assuming poisson distribution of n-ion events.
#'
#' @param intensity Vector of intensities (histogram x-axis data).
#' @param counts Vector of counts (histogram y-axis data).
#' @param siPar Vector with fitted parameter values.
#' @return A list with the fitted rate (ions/extraction) and vector with the
#' fitted multi-ion distribution.
#'
#' @family Single ion histogramming functions
#' @export
SiFitRateFromPhd <- function(intensity, counts, siPar) {
    .Call(`_TofDaqR_SiFitRateFromPhd`, intensity, counts, siPar)
}

#' Gets IP address of TPS2.
#'
#' \code{FindTpsIp} listens for UDP packets that TPS2 broadcast and returns
#' the IP of the TPS2.
#'
#' Note that executing this function makes your program to a UDP server and
#' Windows firewall (or other personal firewall software) will query for
#' permission.
#'
#' @param TpsSerial Serial number of TPS2.
#' @param timeout Timeout in ms to wait for the UDP packet.
#' @return String of IP address.
#'
#' @examples
#' \dontrun{
#' FindTpsIp("910.33.0316", 500)
#' }
#' @export
FindTpsIp <- function(TpsSerial, timeout) {
    .Call(`_TofDaqR_FindTpsIp`, TpsSerial, timeout)
}

